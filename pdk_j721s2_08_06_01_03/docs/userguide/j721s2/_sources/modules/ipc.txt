IPC
===

Introduction
------------


TI |__PART_FAMILY_NAME__| family of devices consists of many cores - |__PART_CORTEX_A_CORE_NAME__| , R5Fs (MCU or Main Domain) and/or DSPs (C66x / C7x). The actual cores vary with actual device. Refer to the datasheet of the device for the actual cores present on SoC. Inter-Processor Communication (IPC) provides a communication channel between various cores. IPCLLD is the low-level driver for IPC, which provides a core-agnostic and OS-agnostic framework for communication.

More information regarding the `TI multicore processors <http://www.ti.com/processors/automotive-processors/overview.html>`_ is available .


Terms and Abbreviation
------------------------

=======   =============================================
Term      Definition or Explanation
=======   =============================================
IPC       Inter-Processor Communication
VirtIO    Virtual I/O driver
MailBox   IP which provides queued interrupt mechanism  for communication channel
VRing     Ring Buffer in shared memory
PDK       Platform Development Kit
=======   =============================================


References
-----------

.. ifconfig:: CONFIG_family in ('am65xx')

     * `Sitara Processor Datasheet <http://www.ti.com/lit/gpn/am6548>`_

.. ifconfig:: CONFIG_family in ('jacinto', 'j7200')

     *  For |__PART_DEFAULT_SOC_CAPS__| datasheet, please contact TI representative


Features
--------

* Provides ipc low-level driver, which can be compiled for any of the cores on |__PART_FAMILY_NAME__| devices
* Supports RTOS/RTOS communication and Linux/RTOS concurrently for all cores
* Supports RTOS, Linux, QNX (for select devices) and baremetal (No-OS) usecases.
* It can be extended for any third-party RTOS by adding OS adaptation layer
* IPCLLD also provides many examples for quick reference


Installation
------------

IPCLLD is part of TI PDK (Platform Development Kit) package. Once Processor SDK RTOS is installed, PDK and all dependent packages and tool-chains are installed automatically.
IPCLLD can also be located at <PRSDK_HOME>/pdk/packages/ti/drv/ipc. IPCLLD is also available publically at `<https://git.ti.com/processor-sdk/pdk/>`_ at packages/ti/drv/ipc.

It can also be cloned using following git command:

* git clone git://git.ti.com/processor-sdk/pdk.git
* Provides many examples for quick reference

The file and directory oraganization are as below. Note that this is a representative snapshot and additional/different soc folders and examples may be present in latest codebase.

 .. image:: ../../images/ipc/ipclld_file_org.png
                :height: 944
                :width: 435


Build
-----

IPCLLD uses the PDK build systems to build the IPCLLD library and example applications.

Dependency of External PDK Components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. ifconfig:: CONFIG_family in ('jacinto', 'j7200', 'am65xx')

    IPCLLD does not access any hardware directly. It uses the PDK/csl component to configure the Mailbox registers. It uses sciclient to set/release the Mailbox interrupts. Also it uses PDK/osal to configure OS-related steps like Semaphore, etc.

    +-----------------------------+----------------------------------------------+
    | PDK component               | Use by IPCLLD                                |
    +=============================+==============================================+
    | csl                         | Configures Mailbox registers                 |
    +-----------------------------+----------------------------------------------+
    | sciclient                   | Set Mailbox interrupts                       |
    +-----------------------------+----------------------------------------------+
    | osal                        | To register for HWI and other kernel stuffs. |
    +-----------------------------+----------------------------------------------+

.. ifconfig:: CONFIG_family in ('am64x')

    IPCLLD does not access any hardware directly. It uses the PDK Mailbox LLD component for Mailbox access. Mailbox LLD performs the Mailbox register configuration. Also it uses PDK/osal to configure OS-related steps like Semaphore, etc.

    +-----------------------------+----------------------------------------------+
    | PDK component               | Use by IPCLLD                                |
    +=============================+==============================================+
    | mailbox                     | Mailbox access                               |
    +-----------------------------+----------------------------------------------+
    | osal                        | To register for HWI and other kernel stuffs. |
    +-----------------------------+----------------------------------------------+



Command to build IPCLLD
^^^^^^^^^^^^^^^^^^^^^^^^

The build can be done either from the IPCLLD's path in the PDK packages, or from the PDK build folder. For either method, the following environment variables must be defined, or supplied with the build command (if they are different from the defaults of the SDK installation):

- SDK_INSTALL_PATH: Installation root for sdk
- TOOLS_INSTALL_PATH: where all the tool chains are installed, if different from SDK_INSTALL_PATH
- PDK_INSTALL_PATH: Installtion root for pdk

The following build instructions are for Linux. For Windows build, please replace "make" with "gmake".

Method 1:

These libraries and examples are built from the IPCLLD's path in the PDK packages:

    PDK_INSTALL_DIR/packages/ti/drv/ipc

=======  ======================================================================================  ===========
Target   Build Command                                                                           Description
=======  ======================================================================================  ===========
lib      make PDK_INSTALL_PATH=PDK_INSTALL_DIR/packages SDK_INSTALL_PATH=SDK_INSTALL_PATH lib    IPCLLD library
apps     make PDK_INSTALL_PATH=PDK_INSTALL_DIR/packages SDK_INSTALL_PATH=SDK_INSTALL_PATH apps   IPCLLD examples
clean    make PDK_INSTALL_PATH=PDK_INSTALL_DIR/packages SDK_INSTALL_PATH=SDK_INSTALL_PATH clean  Clean IPCLLD library and examples
all      make PDK_INSTALL_PATH=PDK_INSTALL_DIR/packages SDK_INSTALL_PATH=SDK_INSTALL_PATH all    Build IPCLLD library and examples
=======  ======================================================================================  ===========

Method 2:

If building from the PDK build folder, then use following steps to build

    Go to PDK_INSTALL_DIR/packages/ti/build

=======  =========================================================================================================================  ===========
Target   Build Command                                                                                                              Description
=======  =========================================================================================================================  ===========
lib      make -s -j BUILD_PROFILE=<debug/release> BOARD=< |__PART_DEFAULT_BOARD__| > CORE=<core_name> ipc                           IPCLLD library
example  make -s -j BUILD_PROFILE=<debug/release> BOARD=< |__PART_DEFAULT_BOARD__| > CORE=<core_name> ipc_echo_test_freertos        ipc_echo_test example (this can be replaced with any available IPC test name to build the specific test)
clean    make -s -j BUILD_PROFILE=<debug/release> BOARD=< |__PART_DEFAULT_BOARD__| > CORE=<core_name> ipc_echo_test_freertos_clean  Clean the ipc_echo_test (this can be replaced with any available IPC test name to build the specific test)
=======  =========================================================================================================================  ===========

See `Example Details`_ for list of supported examples.

Available Core names
^^^^^^^^^^^^^^^^^^^^

.. ifconfig:: CONFIG_family in ('am65xx')

     AM65XX:
          - mpu1_0 (A53)
          - mcu1_0 (r5f0_0)
          - mcu1_1 (r5f0_1)

.. ifconfig:: CONFIG_family in ('jacinto')

     J721E:
          - mpu1_0 (A72)
          - mcu1_0 (mcu-r5f0_0)
          - mcu1_1 (mcu-r5f0_1)
          - mcu2_0 (main-r5f0_0)
          - mcu2_1 (main-r5f0_1)
          - mcu3_0 (main-r5f1_0)
          - mcu3_1 (main-r5f1_1)
          - c66xdsp_1 (c66x_0)
          - c66xdsp_2 (c66x_1)
          - c7x_1 (c71x_0)

.. ifconfig:: CONFIG_family in ('j7200')

     J7200:
          - mpu1_0 (A72)
          - mcu1_0 (mcu-r5f0_0)
          - mcu1_1 (mcu-r5f0_1)
          - mcu2_0 (main-r5f0_0)
          - mcu2_1 (main-r5f0_1)

.. ifconfig:: CONFIG_family in ('am64x')

     AM64X:
          - mpu1_0 (A53)
          - mcu1_0 (r5f0_0)
          - mcu1_1 (r5f0_1)
          - mcu2_0 (r5f1_0)
          - mcu2_1 (r5f1_1)
          - m4f_0 (M4)

Expected Output
^^^^^^^^^^^^^^^

The built example binaries can be found in the PDK's binary folder:

    PDK_INSTALL_PATH/packages/ti/binary/<test_name>/bin/|__PART_DEFAULT_BOARD__|/

Running the IPCLLD examples
---------------------------

IPCLLD comes with the following examples.

Example Details
^^^^^^^^^^^^^^^

+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
|| Name                                || Description                 || Expected Results            || SoC Supported      || Cores Supported || Build Type         |
+======================================+==============================+==============================+=====================+==================+=====================+
| ipc_echo_test                        || This is the most generic    || At the end of the           |    AM65XX           || mcu1_0          | makefile            |
|                                      | application where mpu1_0     |  10000 iterations with       |                     || mcu1_1          |                     |
|                                      | is running Linux, and all    |  a remote core, a            +---------------------+------------------+---------------------+
|                                      | other cores are running      |  ping/pong completed         |    J721E            || mcu1_0          | makefile            |
|                                      | BIOS. All cores talk to      |  message is printed to       |                     || mcu1_1          |                     |
|                                      | each other bi-directionally. |  the core's trace buffer.    |                     || mcu2_0          |                     |
|                                      | Each core will send a ping   || The buffer may be viewed    |                     || mcu2_1          |                     |
|                                      | message and remote end will  | with ROV or Linux remotecore |                     || mcu3_0          |                     |
|                                      | respond with a pong message. | trace buffer.                |                     || mcu3_1          |                     |
|                                      || There are 10000 ping/pong   || After insmod of the         |                     || c66xdsp_1       |                     |
|                                      | messages exchanged between   |  rpmsg-client-sample         |                     || c66xdsp_2       |                     |
|                                      | each core pair.              |  kernel module, traces       |                     || c7x_1           |                     |
|                                      || The messaging with Linux is |  indicating the ping/pong    +---------------------+------------------+---------------------+
|                                      | initiated from Linux using   |  process are printed to      |    J7200            || mcu1_0          | makefile            |
|                                      | rpmsg-client-sample.         |  the Linux console for       |                     || mcu1_1          |                     |
|                                      |                              |  each message to indicate    |                     || mcu2_0          |                     |
|                                      |                              |  success.                    |                     || mcu2_1          |                     |
|                                      |                              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    AM64X            || mcu1_0          | makefile            |
|                                      |                              |                              |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
| ipc_echo_baremetal_test              || This is the same as         || At the end of the           |    AM65XX           || mcu1_0          | makefile            |
|                                      | ipc_echo_test, but with      |  10000 iterations with       |                     || mcu1_1          |                     |
|                                      | baremetal instead of RTOS.   |  a remote core, a            +---------------------+------------------+---------------------+
|                                      || Only the R5Fs are supported |  ping/pong completed         |    J721E            || mcu1_0          | makefile            |
|                                      | for this test.               |  message is printed to       |                     || mcu1_1          |                     |
|                                      |                              |  the core's trace buffer.    |                     || mcu2_0          |                     |
|                                      |                              || The buffer may be viewed    |                     || mcu2_1          |                     |
|                                      |                              | with Linux remotecore        |                     || mcu3_0          |                     |
|                                      |                              | trace buffer.                |                     || mcu3_1          |                     |
|                                      |                              || After insmod of the         +---------------------+------------------+---------------------+
|                                      |                              |  rpmsg-client-sample         |    J7200            || mcu1_0          | makefile            |
|                                      |                              |  kernel module, traces       |                     || mcu1_1          |                     |
|                                      |                              |  indicating the ping/pong    |                     || mcu2_0          |                     |
|                                      |                              |  process are printed to      |                     || mcu2_1          |                     |
|                                      |                              |  the Linux console for       +---------------------+------------------+---------------------+
|                                      |                              |  each message to indicate    |    AM64X            || mcu1_0          | makefile            |
|                                      |                              |  success.                    |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
| ex01_bios_2core_echo_test            || This is the simple ping/pong|| At the end of the           |    AM65XX           || mcu1_0          | makefile            |
|                                      | application between 2 cores  |  10000 iterations with       |                     || mcu1_1          |                     |
|                                      | running BIOS.                |  a remote core, a            +---------------------+------------------+---------------------+
|                                      || The defaults for which two  |  ping/pong completed         |    J721E            || mcu2_0          | makefile            |
|                                      | cores are used depends on the|  message is printed to       |                     || c66xdsp_1       |                     |
|                                      | platform. Please check the   |  the core's trace buffer.    +---------------------+------------------+---------------------+
|                                      | ex01_bios_2core_echo_test.c  || The buffer may be viewed    |    J7200            || mcu1_0          | makefile            |
|                                      | source file to know the      | with ROV in CCS.             |                     || mcu2_0          |                     |
|                                      | specific cores.              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    AMA64X           || mcu1_0          | makefile            |
|                                      |                              |                              |                     || mcu2_0          |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
| ex02_bios_multicore_echo_test        || All cores are running BIOS  || At the end of the           |    AM65XX           || mpu1_0          | makefile            |
|                                      | with many-to-many            |  10000 iterations with       |                     || mcu1_0          |                     |
|                                      | communication, each core     |  a remote core, a            |                     || mcu1_1          |                     |
|                                      | sending ping/pong with each  |  ping/pong completed         +---------------------+------------------+---------------------+
|                                      | other. In this test mpu1_0   |  message is printed to       |    J721E            || mpu1_0          | makefile            |
|                                      | is also running BIOS.        |  the core's trace buffer.    |                     || mcu1_0          |                     |
|                                      || This test may be used in    || The buffer may be viewed    |                     || mcu1_1          |                     |
|                                      | combination with other cores | with ROV in CCS.             |                     || mcu2_0          |                     |
|                                      | running the baremetal        |                              |                     || mcu2_1          |                     |
|                                      | version of the test          |                              |                     || mcu3_0          |                     |
|                                      | (ex02_baremetal test).       |                              |                     || mcu3_1          |                     |
|                                      |                              |                              |                     || c66xdsp_1       |                     |
|                                      |                              |                              |                     || c66xdsp_2       |                     |
|                                      |                              |                              |                     || c7x_1           |                     |
|                                      |                              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    J7200            || mpu1_0          | makefile            |
|                                      |                              |                              |                     || mcu1_0          |                     |
|                                      |                              |                              |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
|                                      |                              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    AM64X            || mpu1_0          | makefile            |
|                                      |                              |                              |                     || mcu1_0          |                     |
|                                      |                              |                              |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
| ex02_baremetal_multicore_echo_test   || All R5Fs are running        || At the end of the           |    AM65XX           || mcu1_0          | makefile            |
|                                      | baremetal with many-to-many  |  10000 iterations with       |                     || mcu1_1          |                     |
|                                      | communication, each core     |  a remote core, a            +---------------------+------------------+---------------------+
|                                      | sending ping/pong with each  |  ping/pong completed         |    J721E            || mcu1_0          | makefile            |
|                                      | other.                       |  message is printed to       |                     || mcu1_1          |                     |
|                                      |                              |  the core's trace buffer.    |                     || mcu2_0          |                     |
|                                      || This test may be used in    || The buffer may be viewed    |                     || mcu2_1          |                     |
|                                      | combination with other cores | by viewing the trace buffer  |                     || mcu3_0          |                     |
|                                      | running the BIOS             | memory in CCS memory browser |                     || mcu3_1          |                     |
|                                      | version of the test          | window.                      +---------------------+------------------+---------------------+
|                                      | (ex02_bios test).            || The address of the trace    |    J7200            || mcu1_0          | makefile            |
|                                      |                              | buffer can be found by       |                     || mcu1_1          |                     |
|                                      |                              | checking the map file for    |                     || mcu2_0          |                     |
|                                      |                              | the tracebuf section.        |                     || mcu2_1          |                     |
|                                      |                              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    AM64X            || mcu1_0          | makefile            |
|                                      |                              |                              |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
|                                      |                              |                              |                     || m4f_0           |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
| ex03_linux_bios_2core_echo_test      || This is the simple ping/pong|| After insmod of the         |    AM65XX           || mcu1_0          | makefile            |
|                                      | application, where mpu1_0 is | rpmsg-client-sample          +---------------------+------------------+---------------------+
|                                      | running Linux, and all other | kernel module, traces        |    J721E            || mcu1_0          | makefile            |
|                                      | cores are running BIOS.      | indicating the ping/pong     +---------------------+------------------+---------------------+
|                                      | Each of the cores running    | process are printed to       |    J7200            || mcu1_0          | makefile            |
|                                      | BIOS will communicate only   | the Linux console for        +---------------------+------------------+---------------------+
|                                      | with the mpu1_0 running      | each message to indicate     |    AM64X            || mcu1_0          | makefile            |
|                                      | Linux and not with each other| success.                     |                     |                  |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+
| ex04_linux_baremetal_2core_echo_test || This is the simple ping/pong|| After insmod of the         |    AM65XX           || mcu1_0          | makefile            |
|                                      | application, where mpu1_0 is | rpmsg-client-sample          |                     || mcu1_1          |                     |
|                                      | running Linux, and all other | kernel module, traces        +---------------------+------------------+---------------------+
|                                      | cores are running baremetal  | indicating the ping/pong     |    J721E            || mcu1_0          | makefile            |
|                                      | Each of the cores running    | process are printed to       |                     || mcu1_1          |                     |
|                                      | baremetal will communicate   | the Linux console for each   |                     || mcu2_0          |                     |
|                                      | only with the mpu1_0 running | message to indicate          |                     || mcu2_1          |                     |
|                                      | Linux and not with each      | success.                     |                     || mcu3_0          |                     |
|                                      | other.                       |                              |                     || mcu3_1          |                     |
|                                      |                              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    J7200            || mcu1_0          | makefile            |
|                                      |                              |                              |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
|                                      |                              |                              +---------------------+------------------+---------------------+
|                                      |                              |                              |    AM64X            || mcu1_0          | makefile            |
|                                      |                              |                              |                     || mcu1_1          |                     |
|                                      |                              |                              |                     || mcu2_0          |                     |
|                                      |                              |                              |                     || mcu2_1          |                     |
+--------------------------------------+------------------------------+------------------------------+---------------------+------------------+---------------------+

Loading Remote Firmware
^^^^^^^^^^^^^^^^^^^^^^^

Remote firmware can be loading using CCS or using uBoot SPL.

1. **Loading using CCS** :

    Sciclient module contains default system firmware and CCS script to load the system firmware. The load scripts should be modified to reflect the correct full-path of the script location. 

    * Refer the |__PART_BOARD_CCS_SETUP__| section for details of setting up the CCS target configuration and loading system firmware.

    * Load the remote binaries

        - Menu **Run --> Load Program**

    * Run the cores.
    * After running the cores, the sample output should look something like below.

      .. image:: ../../images/ipc/ipclld_Sample_output_mpu.png
                :height: 377
                :width: 672


2. **Loading using SPL/uBoot**

  Run following steps to configure remote firmware for SPL loading with HLOS running on MPU

  1) Copy the remote firmware to rootfs at /lib/firmware/pdk-ipc folder
  2) cd /lib/firmware
  3) Remove old soft link for remote cores

     .. ifconfig:: CONFIG_family in ('jacinto', 'j7200')

          * rm j7*

     .. ifconfig:: CONFIG_family in ('am65xx', 'am64x')

          * rm am*

  4) Create new soft links

     .. ifconfig:: CONFIG_family in ('jacinto')

          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_c66xdsp_1_release.xe66 j7-c66_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_c66xdsp_2_release.xe66 j7-c66_1-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_c7x_1_release.xe71     j7-c71_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu3_0_release.xer5f   j7-main-r5f1_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu3_1_release.xer5f   j7-main-r5f1_1-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu2_0_release.xer5f   j7-main-r5f0_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu2_1_release.xer5f   j7-main-r5f0_1-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_testb_mcu1_0_release.xer5f  j7-mcu-r5f0_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu1_1_release.xer5f   j7-mcu-r5f0_1-fw

     .. ifconfig:: CONFIG_family in ('j7200')

          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu2_0_release.xer5f   j7200-main-r5f0_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu2_1_release.xer5f   j7200-main-r5f0_1-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_testb_mcu1_0_release.xer5f  j7200-mcu-r5f0_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu1_1_release.xer5f   j7200-mcu-r5f0_1-fw

     .. ifconfig:: CONFIG_family in ('am65xx')

          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu1_0_release.xer5f   am65x-mcu-r5f0_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu1_1_release.xer5f   am65x-mcu-r5f0_1-fw

     .. ifconfig:: CONFIG_family in ('am64x')

          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu2_0_release.xer5f   am64-main-r5f1_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu2_1_release.xer5f   am64-main-r5f1_1-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu1_0_release.xer5f   am64-main-r5f0_0-fw
          * ln -s /lib/firmware/pdk-ipc/ipc_echo_test_mcu1_1_release.xer5f   am64-main-r5f0_1-fw

  5) sync : write the changes to filesystem
  6) Reboot the system


Running the Echo Tests
^^^^^^^^^^^^^^^^^^^^^^^^^

In this section ipc_echo_test is used to demonstrate, but same instructions apply to other examples that have Linux on MPU, though test output may be slightly different.

  1) Login as root
  2) Start sample app as below

     - modprobe rpmsg_client_sample count=5

     .. image:: ../../images/ipc/ipclld_Linux_Start.png
                :height: 270
                :width: 581

   3) After running the sample app, it should display something below

    .. image:: ../../images/ipc/ipclld_linux_output.png
                :height: 796px
                :width: 983px


IPCLLD Design Details
---------------------

- Ring Buffer is used as shared memory to transfer the data. It must be reserved system wide. The base-address and size of ring Buffer must be provided to IPCLLD. It must be same for all core applications. The invidual memory-range for Ring Buffer between core combinations are calculated internally inside the library. The default base-address and size used in the IPC examples is

.. ifconfig:: CONFIG_family in ('jacinto')

     =======  =============  ==========
     Device   Base Address   Size
     =======  =============  ==========
     J721E    0xAA000000     0x1C00000
     =======  =============  ==========

.. ifconfig:: CONFIG_family in ('j7200')

     =======  =============  ==========
     Device   Base Address   Size
     =======  =============  ==========
     J7200    0xA4000000     0x800000
     =======  =============  ==========

.. ifconfig:: CONFIG_family in ('am65xx')

     =======  =============  ==========
     Device   Base Address   Size
     =======  =============  ==========
     AM65XX   0xA2000000     0x200000
     =======  =============  ==========

.. ifconfig:: CONFIG_family in ('am64x')

     =======  =============  ==========
     Device   Base Address   Size
     =======  =============  ==========
     AM64X    0xA5000000     0x800000
     =======  =============  ==========

The VRing base address and size is passed from the application during the Ipc_initVirtIO() call. See `Writing HelloWorld App using IPCLLD`_ for the example of usage.

Additionally the Ring Buffer memory used when communicating with MPU running Linux must be reserved system wide. The base-address and size of the ring buffer is different from what is used between cores not running Linux. The base-address and size of the ring Buffer is provided to IPCLLD when Linux updates the core's resource table with the allocated addresses. Linux allocates the base-address from the first memory-region. See `Resource Table`_ for more information.

- For each RPmessage object, the memory must be provided to library from local heap. All subsequent send/recv API is using rpmessage buffer provided during the create function.
- Maximum payload/user message size that can be transferred by RPMessage is 496 bytes. For larger data transfers, it is recommended to pass a pointer/handle/offset to a larger shared memory buffer inside the message data.
- For firmware that will communicate with Linux over IPC, a Resource Table is required. See `Resource Table`_ for more information.

Typical Data-Flow in IPCLLD communication between two cores
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Following picture illustrates the data flow between two cores using mailbox IP as transport.

.. image:: ../../images/ipc/ipclld_data_flow.png
                :height: 470
                :width: 687

Resource Table
^^^^^^^^^^^^^^
For applications that will use Linux IPC, a resource table is required. Example resource tables can be found in the IPC examples:

.. ifconfig:: CONFIG_family in ('jacinto')

     ========  =========================================
     Device    Resource Table Example Location
     ========  =========================================
     J721E     examples/common/src/ipc_rsctable.h
     ========  =========================================

.. ifconfig:: CONFIG_family in ('j7200')

     ========  =========================================
     Device    Resource Table Example Location
     ========  =========================================
     J7200     examples/common/src/ipc_rsctable.h
     ========  =========================================

.. ifconfig:: CONFIG_family in ('am65xx')

     ========  =========================================
     Device    Resource Table Example Location
     ========  =========================================
     AM65XX    examples/common/src/ipc_am65xx_rsctable.h
     ========  =========================================

.. ifconfig:: CONFIG_family in ('am64x')

     ========  =========================================
     Device    Resource Table Example Location
     ========  =========================================
     AM64X     examples/common/src/ipc_rsctable.h
     ========  =========================================

The resource table must have at least one entry, the VDEV entry, to define the the vrings used for IPC communication with Linux.
Optionally, the resource table can also have a TRACE entry which defines the location of the remote core trace buffer.

The VDEV entry specifies the address as RPMSG_VRING_ADDR_ANY, meaning that the address will be allocated by the Linux driver during loading. The allocation is made from the first memory-region specified in the dts file for the remote core. For example, if the dts entry for mcu_r5fss0_core0 is ::

    reserved_memory: reserved-memory {
        #address-cells = <2>;
	#size-cells = <2>;
	ranges;

	mcu_r5fss0_core0_dma_memory_region: r5f-dma-memory@a0000000 {
        	compatible = "shared-dma-pool";
        	reg = <0 0xa0000000 0 0x100000>;
        	no-map;
        };

        mcu_r5fss0_core0_memory_region: r5f-memory@a0100000 {
        	compatible = "shared-dma-pool";
        	reg = <0 0xa0100000 0 0xf00000>;
        	no-map;
        };
    }

then the allocation for the vrings for mcu_r5fss0_core0 will come from the 0xa0000000 entry.

Note that this address is specific to the Linux<->remote core VRING, and is different from the address provided to the Virtio module in the remote core firmware in the call to Ipc_initVirtIO.

Memory Considerations
^^^^^^^^^^^^^^^^^^^^^
As mentioned in `IPCLLD Design Details`_, the Ring Buffer memory must be reserved system-wide. In addition, the Ring Buffer memory should be configured as non-cached on all cores using IPCLLD. For examples of configurations for Ring Buffer memory, refer to the examples in pdk/packages/ti/drv/ipc/examples/.

Writing HelloWorld App using IPCLLD
-----------------------------------
- **Step1: Initialize MultiProc with SelfId, and how many remote cores** ::

     Ipc_mpSetConfig(selfProcId, numProc, remoteProc);

- **Step2a: Initialize the Ipc module (RTOS case).** ::

     /* Use NULL for params pointer to take all default params */
     Ipc_init(NULL);

- **Step2b: Initialize the Ipc module (baremetal case)** ::

     /* Init the params to default and specify the custom newMsgFxn to be notified of new message arrival */
     Ipc_initPrms_init(0U, &initPrms);
     initPrms.newMsgFxn = &IpcTestBaremetalNewMsgCb;
     Ipc_init(&initPrms);

- **Step3: Load the Resource Table (required only if running Linux on A72/A53)** ::

     Ipc_loadResourceTable((void*)&ti_ipc_remoteproc_ResourceTable);

See `Resource Table`_ for details on the resource table.

- **Step4: Initialize VirtIO (note: Base Address for Shared Memory used for RingBuffer)** ::

     vqParam.vqObjBaseAddr = (void*)sysVqBuf;
     vqParam.vqBufSize     = numProc * Ipc_getVqObjMemoryRequiredPerCore();
     vqParam.vringBaseAddr = (void*)VRING_BASE_ADDRESS;
     vqParam.vringBufSize  = VRING_BUFFER_SIZE;
     Ipc_initVirtIO(&vqParam);

- **Step5: Initialize RPMessage** ::

     RPMessage_init(&cntrlParam);

- **Step6: Send Message** ::

     RPMessage_send(handle, dstProc, ENDPT1, myEndPt, (Ptr)buf, len);

- **Step7a: Receive Message (RTOS case)** ::

     RPMessage_recv(handle, (Ptr)buf, &len, &remoteEndPt, &remoteProcId, timeout);

- **Step7b: Receive Message (baremetal case)** ::

     /* After the IPCLLD notifies the app of a new message available via the newMsgFxn, app can call the non-blocking variant to get the message */
     RPMessage_recvNb(handle, (Ptr)buf, &len, &remoteEndPt, &remoteProcId);
