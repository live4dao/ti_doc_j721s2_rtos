<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>MCUSW: Pwm Design Document</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCUSW
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('design_pwm_top.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Pwm Design Document </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="design_pwm_intro"></a>
Introduction</h1>
<hr/>
<p> This document describes the functionality, API and configuration of the AUTOSAR BSW module PWM</p><ul>
<li>Supported AUTOSAR Release <b>: 4.3.1</b></li>
<li>Supported Configuration Variants <b>: Pre-Compile &amp; Post-Build </b></li>
<li>Vendor ID <b>: PWM_VENDOR_ID (44)</b></li>
<li>Module ID <b>: PWM_MODULE_ID (121)</b></li>
</ul>
<h2><a class="anchor" id="design_pwm_intro_overview"></a>
Overview</h2>
<p>The figure below depicts the AUTOSAR layered architecture as 3 distinct layers,</p><ul>
<li>Application</li>
<li>Runtime Environment (RTE) and</li>
<li>Basic Software (BSW).</li>
</ul>
<p>The BSW is further divided into 4 layers:</p><ul>
<li>Services</li>
<li>Electronic Control Unit Abstraction</li>
<li>MicroController Abstraction (MCAL) and</li>
<li>Complex Drivers.</li>
</ul>
<div class="image">
<img src="autosar_acrhitecture_common.png" alt="autosar_acrhitecture_common.png"/>
<div class="caption">
AUTOSAR Architecture</div></div>
<p>MCAL is the lowest abstraction layer of the Basic Software. It contains software modules that interact with the Microcontroller and its internal peripherals directly. The PWM driver is a part of the microcontroller (peripheral) Driver module which is a part of the Basic Software. The figure below shows the position of the PWM driver in the AUTOSAR Architecture.</p>
<div class="image">
<img src="autosar_acrhitecture_pwm.png" alt="autosar_acrhitecture_pwm.png"/>
<div class="caption">
AUTOSAR Architecture – PWM MCAL</div></div>
<hr/>
 <h2><a class="anchor" id="design_pwm_overview"></a>
PWM Overview</h2>
<p>The PWM module implements an interface in C programming language for handling the PWM functionality of the device.This PWM driver takes care of initializing and de-initializing the PWM unit and offers services to:</p><ul>
<li>Generate pulses with variable pulse width(Duty Cycle - can range from 0% to 100%)</li>
<li>Set parameters of a PWM channels waveform(Duty Cycle and Period)</li>
<li>Enable/Disable notifications</li>
</ul>
<div class="image">
<img src="pwm_signal_description.png" alt="pwm_signal_description.png"/>
<div class="caption">
PWM Signal Description</div></div>
<hr/>
 <h2><a class="anchor" id="design_hw_overview"></a>
Hardware Overview</h2>
<p>In this design, the PWM Functionality can be achieved by using either of two available IPs, the DM Timers, or EPWM module.</p>
<h3>DM Timer</h3>
<p>DM Timer available on the device are used. TDA4x class of devices includes multiple timers, some of the key features provided are listed below:</p>
<ul>
<li>Free running 32 bit up counter</li>
<li>Auto reload mode (can be used for continuous counter operation)</li>
<li>Support dynamic Start / Stop counter operation</li>
<li>Programmable clock dividers (2n, where n = [0-8])</li>
<li>2 timers modules could be operated in cascaded mode to provide 64bit counter</li>
<li>Programmable interrupt generation on overflow, compare and capture</li>
<li>Programmable clock source</li>
</ul>
<p>There is Support for 3 basic functional modes Timer mode, Capture mode &amp; Compare mode. Refer section 12.8.3 in <a class="el" href="design_pwm_top.html#design_pwm_references">2</a> for more details on timer operation.</p>
<p>Timer pins can be configured to be used as PWM output pins. However, not all timer pins can be configured to be PWM output, please refer TRM for specific pins (section 12.8.3.1 in <a class="el" href="design_pwm_top.html#design_pwm_references">2</a>)</p>
<p>The following image shows the block diagram of Timer which can generate a PWM output:</p>
<div class="image">
<img src="pwm_timer_block_diagram.png" alt="pwm_timer_block_diagram.png"/>
<div class="caption">
Timer Block Diagram</div></div>
<h3>EPWM Module</h3>
<p>The ePWM(enhanced) unit described here addresses these requirements by allocating all needed timing and control resources on a per PWM channel basis. Cross coupling or sharing of resources has been avoided; instead, the ePWM is built up from smaller single channel modules with separate resources and that can operate together as required to form a system. This modular approach results in easy understand of its operation quickly.</p>
<p>J7 family device include six instances of ePWM. The EPWM module represents one complete PWM channel composed of two PWM outputs: EPWMxA and EPWMxB. A given EPWM module functionality can be extended with the so called High-Resolution Pulse Width modulator.</p>
<p>In the further description the letter x within a signal or module name is used to indicate a generic EPWM instance on a device. For example, output signals EPWMxA and EPWMxB refer to the output signals from the EPWMx instance.</p>
<p>There are 6 instances of the EPWM integrated in the device. Each of the Enhanced Pulse Width Modulator (EPWM) includes an Enhanced High Resolution Modulator (HRPWM). The high-resolution functionality is implemented only on the EPWMxA output. EPWMxB output has conventional PWM capabilities. At system level the EPWM0 through EPWM5 integration features are listed below:</p><ul>
<li>A 32-bit slave configuration port on the CBASS0 interconnect.</li>
<li>A single functional clock from PLLCTRL.</li>
<li>2 hardware events per EPWM, that is a total of 12 events. From these events each EPWM:</li>
<li>generates 2 interrupts to the device COMPUTE_CLUSTER0, PRU_ICSSG0_INTC, PRU_ICSSG1_INTC and MAIN2MCU_INTRTR_PLS</li>
<li>A synchronization input/output daisy chain-like connection exists between the EPWM0 trough EPWM5.</li>
</ul>
<p>The high-resolution pulse-width modulator (HRPWM) extends the time resolution capabilities of the conventionally derived digital pulse-width modulator (PWM). HRPWM is typically used when PWM resolution falls below ~9-10 bits. The key features of HRPWM are:</p><ul>
<li>Extended time resolution capability with regards to falling edge.</li>
<li>Used in Duty cycle control methods.</li>
<li>Finer time granularity control or edge positioning using extensions to the Compare A.</li>
<li>Implemented using the A signal path of PWM, that is, on the EPWMxA output. EPWMxB output has conventional PWM capabilities.</li>
</ul>
<p>![](pwm_epwm_block_diagram0.png "EPWM Block Diagram (Note: Unsupported features are grayed boxed.)")</p>
<hr/>
 <h2><a class="anchor" id="design_pwm_references"></a>
References</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Sl No  </th><th class="markdownTableHeadNone">Specification  </th><th class="markdownTableHeadNone">Comment / Link   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">AUTOSAR 4.3.1  </td><td class="markdownTableBodyNone">AUTOSAR Specification for PWM Driver <a href="https://www.autosar.org/fileadmin/user_upload/standards/classic/4-3/AUTOSAR_SWS_PWMDriver.pdf">Intranet Link</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">TDA4x TRM  </td><td class="markdownTableBodyNone">Technical Reference Manual, <a href="http://www.ti.com/product/TDA4VM/technicaldocuments">TDA4X</a> PWM/DM Timer Module is detailed   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">BSW General Requirements / Coding guidelines  </td><td class="markdownTableBodyNone"><a href="https://confluence.itg.ti.com/display/MCAL/Coding+Guidelines">Intranet Link</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">Software Product Specification (SPS)  </td><td class="markdownTableBodyNone"><a href="https://confluence.itg.ti.com/display/MCAL/MCUSW+Software+Product+Specification">Intranet Link</a> Requirements are derived from <a class="el" href="design_pwm_top.html#design_pwm_references">1</a>   </td></tr>
</table>
<hr/>
 <h1><a class="anchor" id="design_pwm_req"></a>
Requirements</h1>
<p>The PWM driver shall implement as per requirements detailed in <a class="el" href="design_pwm_top.html#design_pwm_references">4</a>, <a class="el" href="design_pwm_top.html#design_pwm_references">1</a> and <a class="el" href="design_pwm_top.html#design_pwm_references">3</a>. It is recommended to refer <a class="el" href="design_pwm_top.html#design_pwm_references">1</a> for clarification.</p>
<hr/>
 <h2><a class="anchor" id="design_pwm_features_supported"></a>
Features Supported</h2>
<p>Below listed are some of the key features that are expected to be supported</p><ul>
<li>Changing of frequency and duty cycle for a PWM channel at runtime besides the default configuration.</li>
<li>The PWM signal that can be generated is a square wave with variable duty cycle and period .</li>
</ul>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_001  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-965, MCAL-3503, MCAL-3509, MCAL-3511, MCAL-3536, MCAL-3537, MCAL-3538, MCAL-3539, MCAL-3540, MCAL-3554, MCAL-3510, MCAL-3631, MCAL-3535, MCAL-920, MCAL-921, MCAL-922, MCAL-923, MCAL-925,MCAL-929, MCAL-930, MCAL-932, MCAL-933, MCAL-937, MCAL-938, MCAL-939,MCAL-942, MCAL-947, MCAL-980, MCAL-945, MCAL-1056 , MCAL-3502, MCAL-3503, MCAL-3509, MCAL-3511, MCAL-3535, MCAL-3631, MCAL-4475   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <div class="image">
<img src="caution.png" alt="caution.png"/>
</div>
   <h2><a class="anchor" id="design_pwm_features_not_supported"></a>
Features Not Supported / NON Compliance</h2>
<ul>
<li><b>[NON Compliance]</b> APIs related to setting or getting power state of the device is not supported, as hardware itself doesn’t support this feature.</li>
<li><b>[NON Compliance]</b> PwmMcuClockReferencePoint doesn’t refer to McuClockReferencePoint. Refer section (<a class="el" href="design_pwm_top.html#design_pwm_constraints">Constraints</a>) for details.</li>
<li>PWM_FIXED_PERIOD_SHIFTED Pwm Channel Class type is not supported</li>
<li>Standard AUTOSAR PWM specification <a class="el" href="design_pwm_top.html#design_pwm_references">1</a>, categorizes few BSW General Requirements as non-requirements, please refer MCAL-3648 for details</li>
<li>Supports additional configuration parameters, refer section (<a class="el" href="design_pwm_top.html#design_pwm_low_level_api_rb">Pwm_RegisterReadback</a>)</li>
<li>Specifically to EPWM IP, DeadBand, Trip Zone and PWM Chopper sub-modules are bypassed.</li>
</ul>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_002  </td></tr>
<tr>
<td><em><b>Non Requirements</b></em> </td><td>MCAL-3648,MCAL-3642,MCAL-3493,MCAL-3482,MCAL-3522,MCAL-3532,MCAL-3531, MCAL-3512,MCAL-3614,MCAL-3481,MCAL-3613,MCAL-3515,MCAL-3626,MCAL-3478, MCAL-3513,MCAL-3628,MCAL-3629,MCAL-3606,MCAL-3617,MCAL-3602,MCAL-3516, MCAL-3638,MCAL-3608,MCAL-3619,MCAL-3609,MCAL-3514,MCAL-3518,MCAL-3519, MCAL-3630,MCAL-3543,MCAL-3604,MCAL-3517,MCAL-3544,MCAL-3610,MCAL-3627, MCAL-3618,MCAL-3605,MCAL-3639,MCAL-3620,MCAL-3603,MCAL-3521,MCAL-3621, MCAL-3607,MCAL-3484,MCAL-3615,MCAL-3483,MCAL-3622,MCAL-3611,MCAL-3530, MCAL-3520,MCAL-3601,MCAL-3612,MCAL-3623,MCAL-3529,MCAL-3616,MCAL-3489, MCAL-3588,MCAL-3589,MCAL-3591,MCAL-3590,MCAL-3497   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_assumptions"></a>
Assumptions</h2>
<p>Below listed are assumed to valid for this design/implementation, exceptions and other deviations are listed for each explicitly. Care should be taken to ensure these assumptions are addressed.</p>
<ol type="1">
<li>The functional clock to the PWM module is expected to be on before calling any PWM module API.</li>
<li>The PWM driver as such doesn’t perform any PRCM programming to get the functional clock.</li>
<li>For EPWM IP, the modules executes at the system clock which is typically 125Mhz.</li>
<li><b> The clock-source selection for PWM is not performed by the PWM driver, other entities such as SBL, MCAL module MCU shall perform the same. </b></li>
</ol>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_constraints"></a>
Constraints</h2>
<p>Some of the critical constraints of this design are listed below</p>
<ul>
<li>In cases where MCU module is not employed (supported) to configure the clock source for PWM module (refer <a class="el" href="design_pwm_top.html#design_pwm_assumptions">Assumptions</a> sub-item 3). The PWM module configurator shall refer to MCU clock source as listed in specification.</li>
<li>EPWM module executes at the system clock which is typically 125Mhz.</li>
<li>The PWM SWS does not cover PWM emulation on general purpose I/O</li>
<li>Timer when configured for toggle mode with TCLR[11-10] TRG = 0x2 (overflow and match), and TCLR[7] SCPWM Bit = 1 for polarity Low, the first event that toggles the PWM line is an overflow event. If a match event occurs first,it does not toggle the PWM line <table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_003  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3493, MCAL-3502   </td></tr>
</table>
</li>
</ul>
<h3>EPWM</h3>
<p>Setting Prescalers: Period value(Num of ticks) which determines the period is calculated using below formula:</p><ul>
<li>PRD = (TBCLK/PWM_FREQ) / 2.</li>
<li>TBCLK – Time base clock relative to the system clock.</li>
<li>PWM_FREQ – Required output frequency.</li>
<li>/2 – Because UpDown counter is selected.(Please refer DAR for more details). The TRM gives details on this formula.</li>
<li>TBCLK is derived from below formula.</li>
<li>TBCLK = SYS_CLK / (HSPCLKDIV x CLKDIV)</li>
<li>SYS_CLK – System Clock to the PWM which is 125Mhz.</li>
<li>CLKDIV – Time-base Clock Prescale Bits. These bits determine part of the time-base clock prescale value.</li>
</ul>
<p>Actual Division Value = / ( 1 &lt;&lt; CLKDIV) i.e</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Actual Division Value  </th><th class="markdownTableHeadNone">CLKDIV Value   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0  </td><td class="markdownTableBodyNone">/ 1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x1  </td><td class="markdownTableBodyNone">/ 2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x2  </td><td class="markdownTableBodyNone">/ 4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x3  </td><td class="markdownTableBodyNone">/ 8   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x4  </td><td class="markdownTableBodyNone">/ 16   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x5  </td><td class="markdownTableBodyNone">/ 32   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x6  </td><td class="markdownTableBodyNone">/ 64   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x7  </td><td class="markdownTableBodyNone">/ 128   </td></tr>
</table>
<ul>
<li>HSPCLKDIV – High-Speed Time-base Clock Prescale Bits. These bits determine part of the time-base clock prescale value.</li>
</ul>
<p>Actual Division Value = / (HSPCLKDIV * 2) i.e</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Actual Division Value  </th><th class="markdownTableHeadNone">HSPCLKDIV   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0  </td><td class="markdownTableBodyNone">/ 1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x1  </td><td class="markdownTableBodyNone">/ 2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x2  </td><td class="markdownTableBodyNone">/ 4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x3  </td><td class="markdownTableBodyNone">/ 6   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x4  </td><td class="markdownTableBodyNone">/ 8   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x5  </td><td class="markdownTableBodyNone">/ 10   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x6  </td><td class="markdownTableBodyNone">/ 12   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x7  </td><td class="markdownTableBodyNone">/ 14   </td></tr>
</table>
<p>There is a chance that period value calculated is fractional, and therefore required frequency cannot be achieved. The clock dividers need to be selected correctly to avoid such errors. Please refer to the excel sheet provided to derive the correct CLKDIV and HSPCLKDIV values. Using this excel, you can test prescaler combinations with required frequency and ensure that the "Difference" is 0. The Period value should be less than or equal to 65535 (16bit HW register size for period).</p>
<p>Find the excel sheet here: <a href="../images/Pwm_Frequency_Prescalers.xlsx" target="blank"><b>Period Calculator</b></a></p>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="design_pwm_description"></a>
Design Description</h1>
<h2><a class="anchor" id="design_pwm_desc_fundamental"></a>
Fundamental Operation</h2>
<h3>Timer</h3>
<p>The timer can be configured to provide a programmable PWM output. The timer PWM (POTIMERPWM) output pin can be configured to toggle on an event. The TCLR[11-10] TRG bit field determines on which register value the PWM pin toggles. Either overflow or both overflow and match can be selected to toggle the timer PWM pin when a compare condition occurs. TMAR, TLDR The internal overflow pulse is set each time the (0xFFFF FFFF – TLDR[31-0] LOAD_VALUE + 1) value is reached, and the internal match pulse is set when the counter reaches the value of TMAR. Depending on the value of the TCLR[12] PT bit and TCLR[11-10] TRG bit field, the timer provides pulse or PWM event on the output pin (POTIMERPWM). The TLDR and TMAR must keep values below the overflow value (0xFFFF FFFF) by at least two units. If the PWM trigger events are both overflow and match, the difference between the values kept in the TMAR and the value in the TLDR must be at least two units. When match event is used, the compare mode TCLR[6] CE bit must be set.</p>
<p>The following sequence of steps needs to be performed, before the timer can be started</p><ul>
<li>Timer is programmed as configured (in continuous mode or Autoreload mode)</li>
<li>The initial count of the counter TCLR needs to be loaded</li>
<li>The reload register (TLDR) needs to be loaded</li>
<li>The timer is started and the counter (register TCRR), starts counting on every pulse<ul>
<li>As depicted in above figure, TCRR has moved w.r.t to TLDR</li>
</ul>
</li>
</ul>
<div class="image">
<img src="gpt_design_timer_expired.png" alt="gpt_design_timer_expired.png"/>
<div class="caption">
Timer expired</div></div>
<ul>
<li>When the timer expires, the TCRR is loaded with value present in TLDR as show above</li>
<li>An interrupt can be triggered at this point</li>
</ul>
<p>For generating a PWM signal from the timer interrupts, the following cases w.r.t. duty cycle are considered:</p>
<p><b>Case 1: Duty cycle of 0%</b></p><ul>
<li>The output will be the inverse of the configured polarity parameter. For example, if the polarity is configured as LOW, the PWM signal will always be HIGH.</li>
</ul>
<p><b>CASE 2: Duty cycle of 100%</b></p><ul>
<li>The output will be equal to the configured polarity parameter. For example, if the polarity is configured as LOW, the PWM signal will always be LOW.</li>
</ul>
<p><b>Case 3: Duty cycle of 50%</b></p><ul>
<li><p class="startli">When the When a duty cycle of 50% for a PWM signal is required, both the time that the pulse remains HIGH and LOW is equal. In this case, the timer is operated in overflow mode alone (without compare). In one cycle of the PWM signal, the timer should generate an interrupt twice. Hence, the overflow rate for the timer (OVF_Rate) is half the period of the PWM signal required. The load value for TLDR register can be calculated using the following formula: </p><pre class="fragment">   OVF_Rate = (0xFFFF FFFF – TLDR + 1) × (timer-functional clock period) × PS
</pre><p class="startli">where</p><ul>
<li>OVF_Rate = (PWM Period /2 )</li>
<li>Timer-functional clock period is the period of the input clock to the timer</li>
<li>PS is the Prescaler Clock Ratio Value used to divide the timer counter input clock frequency as shown below:</li>
</ul>
</li>
</ul>
<div class="image">
<img src="pwm_timer_prescalar.png" alt="pwm_timer_prescalar.png"/>
<div class="caption">
Prescaler Clock Ratio Values</div></div>
<p><b>Case 4: 0%&lt; Duty cycle &lt; 100%</b></p><ul>
<li><p class="startli">When PWM signal with 0%&lt; duty cycle &lt; 100% for a is required, the timer is operated in overflow and match mode (with compare). In one cycle of the PWM signal, the timer generates an interrupt twice, one when the match condition is met and one when overflow is triggered as shown in the figure below.Hence, in this scenario, the overflow rate for the timer (OVF_Rate) is same as the period of the PWM signal required. </p><div class="image">
<img src="pwm_timer_func.png" alt="pwm_timer_func.png"/>
<div class="caption">
Generation of PWM signal using Timer</div></div>
<p class="startli">The load value for TLDR and TMAR registers can be calculated using the following formula: </p><pre class="fragment">OVF_Rate = (0xFFFF FFFF – TLDR + 1) × (timer-functional clock period) × PS
OVF_Rate * (1- (Dutycyle/100)) = (0xFFFF FFFF – TMAR + 1) × (timer-functional clock period) × PS
</pre><p class="startli">where</p><ul>
<li>OVF_Rate = (PWM Period )</li>
<li>Timer-functional clock period is the period of the input clock to the timer</li>
<li>PS is the Prescaler Clock Ratio Value.</li>
</ul>
<p class="startli">Two example cases are shown in the following figure. The TCLR[7] SCPWM bit is set to 0 in one case and to 1 in the other case. To obtain the desired wave form, start the counter at 0xFFFF FFFE value (to ensure an overflow first) or adjust the line polarity (TCLR[7] SCPWM bit).</p>
<div class="image">
<img src="pwm_from_timer.png" alt="pwm_from_timer.png"/>
<div class="caption">
Timing Diagram for PWM through Timer</div></div>
<p class="startli"><b>NOTE</b></p><ul>
<li>The Functional frequency range dictates the usage of posted and non-posted write modes for the timer. Incase of posted mode of operation, If a write access is pending for a register, reading from this register does not yield a correct result. Software synchronization must be used to avoid incorrect results. Functional frequency range: freq(timer clock) &lt; freq(interface clock)/4.</li>
</ul>
</li>
</ul>
<h3>EPWM</h3>
<div class="image">
<img src="pwm_epwm_submodules.png" alt="pwm_epwm_submodules.png"/>
<div class="caption">
EPWM Submodules</div></div>
<p>EPWM Module in J721E/J7200 consist of submodules:</p>
<p><b>Time-base (TB) </b></p><ul>
<li>Scale the time-base clock (TBCLK) relative to the system clock (FICLK).</li>
<li>Configure the PWM time-base counter (TBCNT) frequency or period.</li>
<li>Time-base counter mode selection:<ol type="1">
<li>count-up mode: used for asymmetric PWM</li>
<li>count-down mode: used for asymmetric PWM</li>
<li>count-up-and-down mode: used for symmetric PWM</li>
</ol>
</li>
<li>Configure the time-base phase relative to another EPWM module.</li>
<li>Synchronize the time-base counter between modules through hardware or software.</li>
<li>Configure the direction (up or down) of the time-base counter after a synchronization event.</li>
<li>Configure how the time-base counter will behave when the device is halted by an emulator.</li>
<li>Specify the source for the synchronization output of the EPWM module:<ol type="1">
<li>Synchronization input signal</li>
<li>Time-base counter equal to zero</li>
<li>Time-base counter equal to counter-compare B (CMPB)</li>
<li>No output synchronization signal generated.</li>
</ol>
</li>
</ul>
<p><b> Counter-compare (CC) </b></p><ul>
<li>Specify the PWM duty cycle for output EPWMxA and/or output EPWMxB</li>
<li>Specify the time at which switching events occur on the EPWMxA or EPWMxB output</li>
</ul>
<p><b> Action-qualifier (AQ) </b></p><ul>
<li>Controls how the two outputs EPWMxA and EPWMxB behave when a particular event occurs.</li>
<li>Possible actions are: Set High, Clear Low, Toggle and Do nothing.</li>
<li>Specify the type of action taken when a time-base or counter-compare submodule event occurs:<ol type="1">
<li>No action taken</li>
<li>Output EPWMxA and/or EPWMxB switched high</li>
<li>Output EPWMxA and/or EPWMxB switched low</li>
<li>Output EPWMxA and/or EPWMxB toggled</li>
</ol>
</li>
<li>Force the PWM output state through software control</li>
<li>Configure and control the PWM dead-band through software</li>
</ul>
<p><b> Event-trigger (ET) </b></p><ul>
<li>Enable the EPWM events that will trigger an interrupt.</li>
<li>Specify the rate at which events cause triggers (every occurrence or every second or third occurrence)</li>
<li>Poll, set, or clear event flags</li>
<li>Manages the events generated by the time-base submodule and the counter-compare submodule to generate an aggregated interrupt request.</li>
<li>An event can be be of the following:<ol type="1">
<li>Time-base counter equal to 0.</li>
<li>Time-base counter equal to period.</li>
<li>Time-base counter equal to the compare A or B register when timer is incr/decr</li>
</ol>
</li>
</ul>
<p><b> High-Resolution PWM (HRPWM) </b></p><ul>
<li>Enable extended time resolution capabilities with regards to falling edge.</li>
<li>Configure finer time granularity control or edge positioning.</li>
<li>Once the EPWM has been configured to provide conventional PWM of a given frequency and polarity, the HRPWM is configured by programming the control HR control register.</li>
<li>Typical low-frequency PWM operations (below 250kHz) may not require the HRPWM capabilities.</li>
<li>HRPWM is based on micro edge positioner (MEP) technology. MEP logic is capable of positioning an edge finely by sub-diving one coarse system clock of a conventional PWM generator. This driver assumes a MEP value of 180 ps.</li>
</ul>
<div class="image">
<img src="pwm_epwm_waveform_3.png" alt="pwm_epwm_waveform_3.png"/>
<div class="caption">
EPWM Waveform : Duty Cycle vs Compare Period Registers</div></div>
<div class="image">
<img src="pwm_epwm_waveform_1.png" alt="pwm_epwm_waveform_1.png"/>
<div class="caption">
EPWM Waveform : Up/Down Counter Example</div></div>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_desc_dynamic"></a>
Dynamic Behavior</h2>
<h3><a class="anchor" id="design_pwm_desc_dynamic_state_timer"></a>
States for Timer</h3>
<p>As the PWM module is implemeted using a timer, as detailed in section 7.1 of <a class="el" href="design_pwm_top.html#design_pwm_references">5</a>, a timer would be in one of the following states. Initialized, running, stopped, expired. The diagram below shows transitions of states:</p>
<div class="image">
<img src="gpt_design_timer_state.png" alt="gpt_design_timer_state.png"/>
<div class="caption">
Timer States : Sourced from TIMER AUTOSAR Spec</div></div>
<h3><a class="anchor" id="design_pwm_desc_dynamic_state_epwm"></a>
States for EPWM</h3>
<ul>
<li>Before <a class="el" href="group__MCAL__PWM__API.html#gaf4d06ec6b8b032b4d39ecbe906bd2e5b" title="Service for PWM initialization.">Pwm_Init()</a> - PWM_STATUS_UNINIT</li>
<li>After <a class="el" href="group__MCAL__PWM__API.html#gaf4d06ec6b8b032b4d39ecbe906bd2e5b" title="Service for PWM initialization.">Pwm_Init()</a> - PWM_STATUS_INIT</li>
<li>After <a class="el" href="group__MCAL__PWM__API.html#gae26fe9b41d6acdb7cda9cefc06626e7c" title="Service for PWM de-initialization.">Pwm_DeInit()</a> - PWM_STATUS_UNINIT</li>
</ul>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_ticks"></a>
Time Unit Ticks</h2>
<p>Refer <a class="el" href="design_pwm_top.html#design_pwm_references">1</a> specifically section 7.2 of the specification for more details All time units used within the API services of the PWM module shall be of the unit ticks.</p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_004  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3511   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_resolution"></a>
Duty Cycle Resolution and Scaling</h2>
<p>Refer <a class="el" href="design_pwm_top.html#design_pwm_references">1</a> specifically section 7.7 of the specification for more details The width of the duty cycle parameter is 16 Bits and the parameter follows the following scaling scheme:</p><ul>
<li>0x0000 means 0%.</li>
<li>0x8000 means 100%. 0x8000 gives the highest resolution while allowing 100% duty cycle to be represented with a 16 bit value.</li>
</ul>
<p>As an implementation guide, the following source code example is given: </p><pre class="fragment">AbsoluteDutyCycle =((uint32)AbsolutePeriodTime * RelativeDutyCycle) &gt;&gt; 15;
</pre><table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_005  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3533,MCAL-3534   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_desc_deter_dir"></a>
Directory Structure</h2>
<p>The directory structure is as depicted in figures below, the source files can be categorized under “Driver Implementation” and “Example Application”</p>
<p><b>Driver Implemented by </b></p><ul>
<li><a class="el" href="Pwm_8h.html" title="This file contains interface header for PWM MCAL driver.">Pwm.h</a> and <a class="el" href="Pwm__Irq_8h.html" title="This file contains ISR function declaration for PWM MCAL driver.">Pwm_Irq.h</a>: Shall implement the interface provided by the driver</li>
<li>Pwm.c, Pwm_Irq.c, Pwm_Gptimer.c, Pwm_Ehrpwm.c Pwm_Priv.c and Pwm_Priv.h: Shall implement the driver functionality</li>
<li>Pwm_Priv.c will act as an abstraction layer. Based on the IP configuration chosen, the respective API will be called.</li>
<li>Gptimer specific API are present in Pwm_Gptimer.c, while EPWM specific are present in Pwm_Ehrpwm.c.</li>
</ul>
<div class="image">
<img src="pwm_driver_dir0.png" alt="pwm_driver_dir0.png"/>
<div class="caption">
Directory Structure of Driver</div></div>
<div class="image">
<img src="pwm_design_dir.png" alt="pwm_design_dir.png"/>
<div class="caption">
Directory Structure</div></div>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_006  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3503,MCAL-3507,MCAL-3506,MCAL-3504,MCAL-3508,MCAL-3505   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="design_pwm_desc_cfg"></a>
Configurator</h2>
<p>The AUTOSAR PWM Driver Specification details mandatory parameters that shall be configurable via the configurator. Please refer section 10 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_007  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3474,MCAL-3475,MCAL-3476,MCAL-3477,MCAL-3478,MCAL-3479,MCAL-3480, MCAL-3481,MCAL-3482,MCAL-3483,MCAL-3484,MCAL-3485,MCAL-3486,MCAL-3487, MCAL-3488,MCAL-3489,MCAL-3490,MCAL-3491,MCAL-3492,MCAL-3493,MCAL-3494, MCAL-3495,MCAL-3496,MCAL-3497,MCAL-3498,MCAL-3499,MCAL-3500,MCAL-3501, MCAL-3652, MCAL-4479   </td></tr>
</table>
<hr/>
 <h3><a class="anchor" id="design_pwm_desc_cfg_ti"></a>
NON Standard configurable parameters</h3>
<p>The design's specific configurable parameters are as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Usage comment   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmDeviceVariant  </td><td class="markdownTableBodyNone">This shall allow integrators to select the device variant for which integration is being performed. This parameter shall be used by driver to impose device specific constraints. The user guide shall detail the device specific constraints   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PwmFunctionalClock  </td><td class="markdownTableBodyNone">This is the value of the System clock frequency in Hz   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmTypeofInterruptFunction  </td><td class="markdownTableBodyNone">This parameter allows the selection of Type of ISR function   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PwmEnableRegisterReadbackApi  </td><td class="markdownTableBodyNone">This parameter enables the API to readback PWM critical registers   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmClkPrescaler  </td><td class="markdownTableBodyNone">This parameter allows the selection of pre-scalar value.The prescaler stage is clocked with the pwm clock and acts as a clock divider for the time-base clock.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PwmPolarity  </td><td class="markdownTableBodyNone">This parameter stores the initial polarity configured for a channel   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmIdleState  </td><td class="markdownTableBodyNone">This parameter stores whether the channel is in idle state   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PwmDefaultOSCounterId  </td><td class="markdownTableBodyNone">This parameter stores Default Os Counter Id if node reference to OsCounter ref PwmOsCounterRef is not set   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmOsCounterRef  </td><td class="markdownTableBodyNone">This parameter contains a reference to the OsCounter, which is used by the Timer driver   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PwmTimeoutDuration  </td><td class="markdownTableBodyNone">This parameter contains the Timer timeout upper limit   </td></tr>
</table>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_008  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3653, MCAL-3654, MCAL-3660, MCAL-3657, MCAL-3752 ,MCAL-3753, MCAL-3754, MCAL-3655   </td></tr>
</table>
<h4>EPWM specific parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Usage comment   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmOutputChSelect  </td><td class="markdownTableBodyNone">PWM Output Channel select EPWMxA or EPWMxB or Both. Both Outputs available with same duty cycle, period and polarity.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PwmHSClkPrescaler  </td><td class="markdownTableBodyNone">This parameter allows the selection of High Speed pre-scalar value. The High Speed prescaler stage is clocked with the pwm clock and acts as a clock divider for the time-base clock. High-Speed Time-base Clock Prescale Bits.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmEnableHighRes  </td><td class="markdownTableBodyNone">This parameter will be a switch to enable or disable high resolution (HRPWM) capability of EPWM module.   </td></tr>
</table>
<p>Standard Config which will be used to differentiate between Gptimer and EHRPWM mode of operation. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Usage comment   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PwmIndex  </td><td class="markdownTableBodyNone">Specifies the InstanceId of this module instance.   </td></tr>
</table>
<ul>
<li>0 - EPWM will be used (Default), 1 - Gptimer will be used</li>
</ul>
<p>Output Channel Structure:</p><ul>
<li>EpwmOuputCh - to choose between the channel A, B or both.</li>
<li>EPWM_OUTPUT_CH_A - Output channel A</li>
<li>EPWM_OUTPUT_CH_B - Output channel B</li>
<li>EPWM_OUTPUT_CH_BOTH_A_AND_B - Both Output channel A and B</li>
</ul>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_desc_cfg_variant"></a>
Variant Support</h3>
<p>The driver shall support both VARIANT-POST-BUILD &amp; VARIANT-PRE-COMPILE</p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_009  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3647, MCAL-3647   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="design_pwm_desc_cfg_dependency"></a>
Dependency on other modules</h2>
<p>In addition to dependencies listed in section 5 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a>, PWM driver shall depend on these modules to realize the required functionality. PWM uses Timer hardware present in the device to realize the functionality, this peripheral requires 2 different clock to be operational, namely ICLK and FCLK.</p>
<h3><a class="anchor" id="design_pwm_desc_cfg_dependency_sbl"></a>
SBL</h3>
<ul>
<li><b>ICLK</b>: Interface clock required for internal operation of the peripheral. This is not expected to change and typically programmed by SBL, please refer the device specific manual for details and valid value.</li>
<li><b>FCLK</b>: Functional clock, used to drive the counter of the timer module. As per AUTOSAR PWM module specification <a class="el" href="design_pwm_top.html#design_pwm_references">1</a>, the PWM driver shall refer MCU Clock reference point. As detailed in section (<a class="el" href="design_pwm_top.html#design_pwm_constraints">Constraints</a>), other entity would require to select the right clock source for the peripheral.</li>
</ul>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="design_pwm_desc_error"></a>
Error Classification</h2>
<p>Errors are classified in two categories, development error and runtime / production error.</p>
<hr/>
 <h3><a class="anchor" id="design_pwm_desc_error_dev"></a>
Development Errors</h3>
<table class="doxtable">
<tr>
<td><em><b> Type of Error </b></em> </td><td><em><b> Related Error code </b></em> </td><td><em><b> Value (Hex)</b></em> </td><td><em><b> Refer Req </b></em>  </td></tr>
<tr>
<td>API Pwm_Init service called with wrong parameter  </td><td>PWM_E_PARAM_CONFIG  </td><td>0x10  </td><td>MCAL-3523   </td></tr>
<tr>
<td>API service used without module initialization  </td><td>PWM_E_UNINIT  </td><td>0x11  </td><td>MCAL-3524   </td></tr>
<tr>
<td>API service used with an invalid channel Identifier  </td><td>PWM_E_PARAM_CHANNEL  </td><td>0x12  </td><td>MCAL-3525   </td></tr>
<tr>
<td>Usage of unauthorized PWM service on PWM channel configured a fixed period </td><td>PWM_E_PERIOD_UNCHANGEABLE  </td><td>0x13  </td><td>MCAL-3526   </td></tr>
<tr>
<td>API Pwm_Init service called while the PWM driver has already been initialised  </td><td>PWM_E_ALREADY_INITIALIZED  </td><td>0x14  </td><td>MCAL-3527   </td></tr>
<tr>
<td>API Pwm_GetVersionInfo is called with a NULL parameter.  </td><td>PWM_E_PARAM_POINTER  </td><td>0x15  </td><td>MCAL-3528   </td></tr>
</table>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_010  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3523, MCAL-3524, MCAL-3525, MCAL-3526, MCAL-3527, MCAL-3528, MCAL-4480, MCAL-4481   </td></tr>
</table>
<h3><a class="anchor" id="design_pwm_desc_error_dev_detect"></a>
Error Detection</h3>
<p>The detection of development errors is configurable (ON / OFF) at pre-compile time. The switch PwmDevErrorDetect will activate or deactivate the detection of all development errors.</p>
<h3><a class="anchor" id="design_pwm_desc_error_dev_notify"></a>
Error notification (DET)</h3>
<p>All detected development errors are reported to Det_ReportError service of the Development Error Tracer (DET).</p>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="design_pwm_desc_res_behave"></a>
Resource Behavior</h2>
<ul>
<li><b> Code Size </b>: Implementation of this driver shall not exceed 40 kilo bytes of code and 5 KB of data section.</li>
</ul>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_011  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3649  </td></tr>
</table>
<ul>
<li><b> Stack Size </b>: Worst case stack utilization shall not exceed 2 kilo bytes.</li>
</ul>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_012  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3650  </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="design_pwm_desc_upgrade_44"></a>
Supporting PWM for AUTOSAR versioned 4.4.0</h2>
<p>This PWM design is based on the requirements specification for AUTOSAR versioned 4.2.1 and sections below highlight some of the critical changes that would be required between these two versions.</p>
<p>Note that this design doesn’t comprehend or account for other versions of AUTOSAR.</p>
<h3>Deleted</h3>
<p>Probably easiest of all to implement. The following have been removed from the requirements specification for AUTOSAR versioned 4.4.0:</p><ul>
<li>[MCAL-3523] : Developement error classification : PWM_E_PARAM_CONFIG</li>
<li>[MCAL-3528] : Developement error classification : PWM_E_PARAM_POINTER</li>
<li>[MCAL-3553] : If development error detection is enabled for the Pwm module, the function Pwm_Init shall raise development error PWM_E_PARAM_CONFIG if ConfigPtr is a null pointer.</li>
<li>[MCAL-3556] : For pre-compile and link time configuration variants, a NULL pointer s hall be passed to the initialization routine</li>
<li>[MCAL-3557] : related to above point In this case the check for this NULL pointer has to be omitted.</li>
<li>[MCAL-3625] : The function Pwm_GetVersionInfo shall be configurable On/Off by the configuration parameter: PwmVersionInfoApi {PWM_VERSION_INFO_API</li>
<li>[MCAL-3642] : If development error detection for the Pwm module is enabled, and a development error occurs, then the corresponding PWM function shall return PWM_LOW for the function Pwm_GetOutputState</li>
<li>[MCAL-3646] : VARIANT-PRE-COMPILE (Pre Compile) is limited to pre-compile configuration parameters only.</li>
<li>[MCAL-3647] :VARIANT-POST-BUILD includes a mix of pre-compile, link time and post build configuration parameters. Also, note that <a class="el" href="design_pwm_top.html#design_pwm_desc_deter_dir">Directory structure</a> would require an update for the removal of the following:</li>
<li>[MCAL-3504] : <a class="el" href="Pwm_8h.html" title="This file contains interface header for PWM MCAL driver.">Pwm.h</a> shall include <a class="el" href="Pwm__Cfg_8h.html" title="This file contains generated pre compile configuration file for PWM MCAL driver.">Pwm_Cfg.h</a></li>
<li>[MCAL-3505] : Pwm_Lcfg.c shall include <a class="el" href="Pwm_8h.html" title="This file contains interface header for PWM MCAL driver.">Pwm.h</a> and Pwm_Memmap.h.</li>
<li>[MCAL-3507] :Pwm_PBcfg.c shall include Pwm_MemMap.h and <a class="el" href="Pwm_8h.html" title="This file contains interface header for PWM MCAL driver.">Pwm.h</a>)</li>
</ul>
<h3>Added</h3>
<p>The following changes have been added in the configurator in the requirements specification for AUTOSAR versioned 4.4.0</p>
<ul>
<li>Module : Configuration of Pwm Module</li>
<li>PwmEcucPartitionRef : this requirement is still in draft state</li>
<li>PwmKernelEcucPartitionRef : this requirement is still in draft state</li>
<li>PwmChannelEcucPartitionRef : this requirement is still in draft state</li>
</ul>
<p>The following changes have been added in the requirements specification for AUTOSAR versioned 4.4.0 :</p><ul>
<li>Development Error Types Added</li>
<li>Runtime Error Types Added</li>
<li>Service name: Pwm_SetDutyCycle (in draft state) as MCAL-3565 has been made obsolete</li>
<li>Service name: Pwm_SetPeriodAndDuty (in draft state) as MCAL-3573 has been made obsolete</li>
<li>Service name: Pwm_SetOutputToIdle (in draft state) as MCAL-3581 has been made obsolete</li>
<li>[MCAL-3642] :If Pwm_GetOutputState is called before module initialization,or with an invalid channel, it shall return PWM_LOW</li>
<li>Service name: Pwm_DisableNotification (draft) please check MCAL-3592 made obsolete</li>
<li>Service name: Pwm_EnableNotification (draft) please check MCAL-3596 made obsolete</li>
<li>In DRAFT The PWM module shall reject configurations with partition mappings which are not supported by the implementation</li>
<li>In DRAFT The ECUC partitions referenced by PwmKernelEcucPartitionRef shall be a subset of the ECUC partitions referenced by PwmEcucPartitionRef</li>
</ul>
<hr/>
<h1><a class="anchor" id="design_pwm_low_level"></a>
Low Level Definitions</h1>
<hr/>
<p> The detailed API and interface description is available as part of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a> &amp; <a class="el" href="design_pwm_top.html#design_pwm_references">4</a>. This section describes the API supported by the MCAL driver and the requirements covered by each of the API.</p>
<h2><a class="anchor" id="design_pwm_low_level_dtypes"></a>
MACROS, Data Types &amp; Structures</h2>
<p>The sections below lists some of key data structures that shall be implemented and used in driver implementation</p>
<h3>Maximum number of channels</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Identifier  </th><th class="markdownTableHeadNone">Comments   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint32  </td><td class="markdownTableBodyNone">PWM_MAX_CHANNELS  </td><td class="markdownTableBodyNone">Defines the maximum number of channels that are configured. Its required that configurations for all channel specified is valid.   </td></tr>
</table>
<h3>Pwm_ChannelType</h3>
<p>Used to specify the numeric identifier for a channel, please refer section 8.2.1 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<h3>Pwm_PeriodType</h3>
<p>Used to specify the period of a PWM channel, refer section 8.2.2 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<h3>Pwm_OutputStateType</h3>
<p>Used to specify the Output state of a PWM channel, refer section 8.2.3 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<h3>Pwm_EdgeNotificationType</h3>
<p>Enumeration used to specify the type of edge notification of a PWM channel. Refer section 8.2.4 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<h3>Pwm_ChannelClassType</h3>
<p>Enumeration used to specify the class of a PWM channel, whether the period is fixed or not. Refer section 8.2.5 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<h3><a class="el" href="structPwm__ConfigType.html" title="Pwm configuration structure.">Pwm_ConfigType</a></h3>
<p>Hardware dependent structure used to specify the initial data for the PWM driver. Refer section 8.2.6 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<h3><a class="anchor" id="design_pwm_low_level_readback_type"></a>
Pwm_RegisterReadbackType</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">IP  </th><th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Range  </th><th class="markdownTableHeadNone">Comments   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pwmRev  </td><td class="markdownTableBodyNone">GPT  </td><td class="markdownTableBodyNone">uint32  </td><td class="markdownTableBodyNone">0 to 0xFFFFFFFF  </td><td class="markdownTableBodyNone">H/W version identifier, will not change for a given SoC   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pwmTtgr  </td><td class="markdownTableBodyNone">GPT  </td><td class="markdownTableBodyNone">uint32  </td><td class="markdownTableBodyNone">0 to 0xFFFFFFFF  </td><td class="markdownTableBodyNone">Shall always read 0xFFFFFFFF   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pwmTimerSynCtrl  </td><td class="markdownTableBodyNone">GPT  </td><td class="markdownTableBodyNone">uint32  </td><td class="markdownTableBodyNone">0 to 0xFFFFFFFF  </td><td class="markdownTableBodyNone">Interface control register, will read 0x00000000   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pwmTbCtl  </td><td class="markdownTableBodyNone">EPWM  </td><td class="markdownTableBodyNone">uint16  </td><td class="markdownTableBodyNone">0 to 0xFFFF  </td><td class="markdownTableBodyNone">Time base Control register   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pwmTbPhs  </td><td class="markdownTableBodyNone">EPWM  </td><td class="markdownTableBodyNone">uint16  </td><td class="markdownTableBodyNone">0 to 0xFFFF  </td><td class="markdownTableBodyNone">Time base Counter Phase register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pwmTbCnt  </td><td class="markdownTableBodyNone">EPWM  </td><td class="markdownTableBodyNone">uint16  </td><td class="markdownTableBodyNone">0 to 0xFFFF  </td><td class="markdownTableBodyNone">Time base Counter Register   </td></tr>
</table>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_013  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3536, MCAL-3537 ,MCAL-3538, MCAL-3539, MCAL-3540, MCAL-3541, MCAL-3542,MCAL-3662   </td></tr>
</table>
<hr/>
 <h2><a class="anchor" id="design_pwm_low_level_api"></a>
APIs</h2>
<p>For the standard APIs please refer 8.3 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a>. Sections below highlight other design considerations for the implementation.</p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_init"></a>
Pwm_Init</h3>
<p>Refer section 8.3.1 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_014  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3553, MCAL-3554, MCAL-3555, MCAL-3558, MCAL-3545, MCAL-3546, MCAL-3547, MCAL-3548, MCAL-3551, MCAL-3552, MCAL-3556, MCAL-3549,MCAL-3550   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_deinit"></a>
Pwm_DeInit</h3>
<p>Refer section 8.3.2 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_015  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3560, MCAL-3559, MCAL-3561,MCAL-3562,MCAL-3563, MCAL-3564,MCAL-3643, MCAL-3640, MCAL-3641, MCAL-3642   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_setduty"></a>
Pwm_SetDutyCycle</h3>
<p>Refer section 8.3.3 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_016  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3565,MCAL-3566, MCAL-3567,MCAL-3568,MCAL-3569, MCAL-3533,MCAL-3534,MCAL-3570,MCAL-3643, MCAL-3645, MCAL-3640, MCAL-3641,MCAL-3642,MCAL-3571,MCAL-3572   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_setperiodduty"></a>
Pwm_SetPeriodAndDuty</h3>
<p>Refer section 8.3.4 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_017  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3573,MCAL-3574,MCAL-3575, MCAL-3576,MCAL-3533 ,MCAL-3534,MCAL-3643, MCAL-3644, MCAL-3645, MCAL-3640, MCAL-3641, MCAL-3642,MCAL-3577,MCAL-3578,MCAL-3579, MCAL-3580   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_setoptoidle"></a>
Pwm_SetOutputToIdle</h3>
<p>Refer section 8.3.5 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_018  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3581, MCAL-3582, MCAL-3583, MCAL-3584, MCAL-3585 MCAL-3586,MCAL-3587  </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_disablenotification"></a>
Pwm_DisableNotification</h3>
<p>Refer section 8.3.7 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_019  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3592,MCAL-3593,MCAL-3594,MCAL-3595, MCAL-3643, MCAL-3645, MCAL-3640, MCAL-3641, MCAL-3642  </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_enablenotification"></a>
Pwm_EnableNotification</h3>
<p>Refer section 8.3.8 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_020  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3596, MCAL-3597,MCAL-3598, MCAL-3599,MCAL-3600, MCAL-3643, MCAL-3645, MCAL-3640, MCAL-3641, MCAL-3642  </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_versioninfo"></a>
Pwm_GetVersionInfo</h3>
<p>Refer section 8.3.13 of <a class="el" href="design_pwm_top.html#design_pwm_references">1</a></p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_021  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3624  </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h3><a class="anchor" id="design_pwm_low_level_api_rb"></a>
Pwm_RegisterReadback</h3>
<p>As noted from previous implementation, the timer configuration registers could potentially be corrupted by other entities (s/w or h/w). One of the recommended detection methods would be to periodically read-back the configuration and confirm configuration is consistent. The service API defined below shall be implemented to enable this detection.</p>
<table class="doxtable">
<tr>
<td><em><b> </b></em> </td><td><em><b>Description</b></em> </td><td><em><b> Comments</b></em>  </td></tr>
<tr>
<td><em><b>Service Name</b></em> </td><td>Pwm_RegisterReadback </td><td>Can potentially be turned OFF  </td></tr>
<tr>
<td><em><b>Syntax</b></em> </td><td>Std_ReturnType Pwm_RegisterReadback(Pwm_ChannelType PwmChannel, <a class="el" href="structPwm__RegisterReadbackType.html" title="PWM register readback structure.">Pwm_RegisterReadbackType</a> * RegRbPtr)  </td><td><a class="el" href="structPwm__RegisterReadbackType.html" title="PWM register readback structure.">Pwm_RegisterReadbackType</a> defines the type, that holds critical values, refer below  </td></tr>
<tr>
<td><em><b>Service ID </b></em> </td><td>0x0F </td><td></td></tr>
<tr>
<td><em><b>Sync / Async </b></em> </td><td>Sync </td><td></td></tr>
<tr>
<td><em><b>Reentrancy</b></em> </td><td>Non Reentrant </td><td></td></tr>
<tr>
<td><em><b>Parameter in</b></em> </td><td>PwmChannel </td><td>Identifies a unique valid channel  </td></tr>
<tr>
<td><em><b>Parameters out</b></em> </td><td>RegRbPtr </td><td>A pointer of type <a class="el" href="structPwm__RegisterReadbackType.html" title="PWM register readback structure.">Pwm_RegisterReadbackType</a>, which holds the read back values   </td></tr>
<tr>
<td><em><b>Return Value</b></em> </td><td>Standard return type </td><td>E_OK or E_NOT_OK in case of invalid channel id  </td></tr>
</table>
<p>The critical register listed is a recommendation and implementation shall determine appropriate registers.</p>
<p>This service could potentially be turned OFF in the configurator. </p><table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_022  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3662,MCAL-3656   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
<h2><a class="anchor" id="design_pwm_low_level_globals"></a>
Global Variables</h2>
<p>This design expects that implementation will require to use following global variables.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable  </th><th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Default Value   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pwm_DrvStatus  </td><td class="markdownTableBodyNone">uint8  </td><td class="markdownTableBodyNone">PWM driver status  </td><td class="markdownTableBodyNone">PWM_STATUS_UNINIT   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Pwm_ChObj  </td><td class="markdownTableBodyNone">Pwm_ChObjType  </td><td class="markdownTableBodyNone">PWM channel object  </td><td class="markdownTableBodyNone">-   </td></tr>
</table>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="design_pwm_safety"></a>
Safety Analysis</h1>
<h2>EPWM Module</h2>
<p>The following tests can be applied as diagnostics for this module (to provide diagnostic coverage on a specific function):</p>
<ul>
<li><b> 1. Software Test of Basic functionality including error tests: </b> Application can use the <a class="el" href="group__MCAL__PWM__API.html#ga190e064c1e150b7d4bdd8115641e68b0" title="Service to enable the Edge Notification.">Pwm_EnableNotification()</a> API to verify correct frequency by counting the number of interrupts received in particular time period. Reference example will be provided in MCAL package. The Unit Test framework will be used to check basic functionality, as well as negative tests by injecting errors.</li>
<li><b> 2. Information redundancy techniques: </b> Application can implement this using GPIO inputs used as interrupts. The interrupts can be timestamped to provide a check on the pulse widths.</li>
<li><b> 3. Monitoring by eCAP: </b> Application can use external eCAP module to monitor the PWM outputs.</li>
<li><b> 4. Periodic software readback of static configuration registers: </b> The driver will internally readback the configured registers to ensure correct value has been set.</li>
<li><b> 5. Software readback of written configuration: </b> The driver provides a <a class="el" href="group__MCAL__PWM__API.html#gac4e2b0df25526b5af86c3aecd001439a" title="This function reads the important registers of the hardware unit and returns the value in the structu...">Pwm_RegisterReadback()</a> API that application can use to check configured register value. Reference example will be provided in MCAL package during later release.</li>
</ul>
<h2>GPTimer Module</h2>
<p>The following tests can be applied as diagnostics for this module (to provide diagnostic coverage on a specific function):</p>
<ul>
<li><b> 1. 1oo2 Voting Using a Second Timer: </b> Application can use other time based modules on the device to periodically check and perform diagnostic on main counter. Example of other external time based modules include PMU (Performance Monitoring Unit), Timer Manager Module and Global Timebase Counter (GTC).</li>
<li><b> 2. Software Test of Basic Functionality including error tests: </b> Application can use the <a class="el" href="group__MCAL__PWM__API.html#ga190e064c1e150b7d4bdd8115641e68b0" title="Service to enable the Edge Notification.">Pwm_EnableNotification()</a> API to verify correct frequency by counting the number of interrupts received in particular time period. Reference example will be provided in MCAL package. The Unit Test framework will be used to check basic functionality, as well as negative tests by injecting errors.</li>
<li><b> 3. Software readback of written configuration: </b> The driver provides a <a class="el" href="group__MCAL__PWM__API.html#gac4e2b0df25526b5af86c3aecd001439a" title="This function reads the important registers of the hardware unit and returns the value in the structu...">Pwm_RegisterReadback()</a> API that application can use to check configured register value. Reference example will be provided in MCAL package during later release.</li>
<li><b> 4. Periodic software readback of static configuration registers: </b> The driver will internally readback the configured registers to ensure correct value has been set.</li>
<li><b> 5. Analog-to-Digital Converter Information redundancy techniques: </b> Information redundancy techniques can be applied via software as an additional runtime diagnostic on ADC conversion. This can be done by application to filter and perform plausibility check to ensure converted values are in expected range.</li>
</ul>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="design_pwm_dar_top"></a>
Decision Analysis &amp; Resolution (DAR)</h1>
<p>Section below list some of the important design decisions and rational behind those decisions.</p>
<h2><a class="anchor" id="design_pwm_dar_timerdutycycle"></a>
Timer Mode configuration in Overflow Only Mode for Duty cycle of 50%</h2>
<p>The PWM signal generation when duty cycle is 50% and 0% &lt; duty cycle &lt; 100% can be done in the following ways:</p><ul>
<li>Configure the timer in overflow only mode in the case where the duty cycle is 50%. In this case, the overflow rate of the timer is kept at half the desired PWM period. When 0% &lt; duty cycle &lt; 100%, the timer is configured in overflow and compare mode with overflow rate kept at the desired period of PWM signal and the formulas given in (<a class="el" href="design_pwm_top.html#design_pwm_desc_fundamental">Fundamental Operation</a>) are used to calculate the compare and reload register values.</li>
<li>Configure the timer in overflow and compare mode always irrespective of duty cycle and the overflow rate is kept at the PWM period and in the case of 50% duty cycle, the compare register TMAR can be kept at half the reload register value.</li>
</ul>
<h3><a class="anchor" id="design_pwm_dar_criteria"></a>
DAR Criteria</h3>
<p>The PWM signal generation from the timer should be optimized.</p>
<h3><a class="anchor" id="design_pwm_dar_alternatives"></a>
Available Alternatives</h3>
<ul>
<li><b> Use timer in either Overflow Mode or ( Overflow and Compare Mode) configuration depending on duty cycle</b><ul>
<li><b> Advantages: </b><ul>
<li>Incase of 50% duty cycle, only the overflow register condition needs to be checked to generate the interrrupts and PWM signal.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>Seperate one time Mode configuration depending on the duty cycle needs to be done in software.</li>
</ul>
</li>
</ul>
</li>
<li><b> Use of Timer in compare and overflow Mode configurations irrespective of duty cycle</b><ul>
<li><b> Advantages: </b><ul>
<li>No need to have seperate Mode configuration of timer for different duty cycles. Timer can be configured in overflow and compare mode.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>In 50% duty cycle, register compare to TMAR register needs to be performed continuously to detect the compare condition.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="design_pwm_dar_decision"></a>
Decision</h3>
<p>The PWM module is more efficeintly implemented by operating timer in overflow mode alone when duty cycle of 50% is required as this avoids the continuous register compare to TMAR to generate the trigger at compare condition. The configuration to overflow or overflow and compare in different duty cycles needs to be done one time, and is a lesser overhead.</p>
<table class="doxtable">
<tr>
<td><em><b>Design ID</b></em> </td><td>DES_PWM_023  </td></tr>
<tr>
<td><em><b>Requirements Covered</b></em> </td><td>MCAL-3533,MCAL-3534   </td></tr>
</table>
<h2><a class="anchor" id="design_pwm_dar_EPWM_GPT"></a>
Integration of GpTimer and EPWM</h2>
<p>The PWM module instance can use either Gptimer hardware or the EPWM hardware IP as the source for signal creation. The most efficient way of integrating both IP into PWM module has to be analyzed.</p>
<h3><a class="anchor" id="design_pwm_EPWM_GPT_dar_criteria"></a>
DAR Criteria</h3>
<p>The PWM driver implementation and interface should be simple and user friendly. The user should be able to choose which one to use.</p>
<h3><a class="anchor" id="design_pwm_EPWM_GPT_dar_alternatives"></a>
Available Alternatives</h3>
<ul>
<li><b> 1. Use PWM Driver Index as the differentiation factor </b><ul>
<li><b> Advantages: </b><ul>
<li>The user can choose which driver instance they want to run (0 for EPWM and 1 for GPT).</li>
<li>This can be provided as a configurable parameter. User has the flexibility to choose.</li>
<li>Easier implementation and simpler integration.</li>
<li>Compatible with the Pre-Compile and Post_Build variants.</li>
<li>Code size will be reduced as only the needed IP libraries will be included.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
<li><b> 2. Have EPWM as default selected </b><ul>
<li>When all EPWM channels are used up, start using the GPT Channels</li>
<li><b> Advantages: </b><ul>
<li>Can use different channels at runtime.</li>
<li>GPTimer will be kept free and would be available for other applications.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>Incompatible with configurator model as Channel ID cannot change at runtime.</li>
<li>User not given the flexibility, and would make the design more complicated.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="design_pwm_EPWM_GPT_dar_decision"></a>
Decision</h3>
<p>Option 1 is chosen as it is most compatible with the configurator and also will make the integration simpler. As mentioned above, the PwmIndex (PWM_INSTANCE_ID) variable will be used as the configuration parameter to choose between EPWM(default) or Gptimer. PWM_Priv.c will call the respective API (will be differentiated using the PWM_INSTNACE_ID).</p>
<h2><a class="anchor" id="design_pwm_dar_EHRPWM"></a>
EHRPWM internal step size</h2>
<p>HRPWM is based on micro edge positioner (MEP) technology. MEP logic is capable of positioning an edge finely by sub-diving one coarse system clock of a conventional PWM generator.</p>
<h3><a class="anchor" id="design_pwm_EPWM_dar_EHRPWM_criteria"></a>
DAR Criteria</h3>
<p>The PWM driver implementation should avoid any failure risks.</p>
<h3><a class="anchor" id="design_pwm_EPWM_dar_alternatives"></a>
Available Alternatives</h3>
<ul>
<li><b> 1. The driver should assume the MEP to be 180ps for all scenarios. </b><ul>
<li><b> Advantages: </b><ul>
<li>This will avoid any failures that come with varied MEP values if user is given freedom to choose.</li>
<li>Will make the driver more stable.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>Driver will only support fixed MEP value.</li>
</ul>
</li>
</ul>
</li>
<li><b> 2. The driver should give the user to select the MEP step size. </b><ul>
<li><b> Advantages: </b><ul>
<li>User has freedom to choose the MEP value.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>Will make driver complicated and prone to user error.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="design_pwm_EPWM_dar_EHRPWM_decision"></a>
Decision</h3>
<p>Option 1 is chosen. Typically MEP scale factor is calibrated in hardware. However, the current hardware does not have an in-built calibration/diagnostic module, so different MEP values cannot be analyzed at run-time. Keeping a fixed MEP value which is suggested by datasheet (180ps) would make the driver functionality simple and stable.</p>
<h2><a class="anchor" id="design_pwm_dar_EPWM_Channel"></a>
Support each EPWM Output as a PWM Channel</h2>
<p>The PWM module instance is composed of two PWM outputs: EPWMxA and EPWMxB. It is possible to consider each output as one channel. In this way we can support 12 PWM outputs in case of J721E/J7200 simultaneously.</p>
<h3><a class="anchor" id="design_pwm_EPWM_dar_Channel_criteria"></a>
DAR Criteria</h3>
<p>The PWM driver implementation and interface should be easily controllable.</p>
<h3><a class="anchor" id="design_pwm_EPWM_dar_Channel_alternatives"></a>
Available Alternatives</h3>
<ul>
<li><b> 1. Link each HW PWM instance as 1 individual PWM Channel </b><ul>
<li><b> Advantages: </b><ul>
<li>It is possible to link only one output of each instance as one individual PWM Channel.</li>
<li>Each PWM output is independent and frequency, duty cycle and polarity can be controlled independently.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>In this way we can support only 6 PWM outputs in case of J721E/J7200 simultaneously.</li>
<li>Interrupt can be generated only for one of the event output either EPWMxA or EPWMxB since each instance has only one interrupt line.</li>
</ul>
</li>
</ul>
</li>
<li><b> 2. Link each HW PWM instance output(EPWMxA or EPWMxB) as 1 individual PWM Channel </b><ul>
<li><b> Advantages: </b><ul>
<li>Each instance consists of two outputs(EPWMxA and EPWMxB) and can be considered as individual PWM Channels.</li>
<li>Each instance outputs can have a different duty cycle and polarity.</li>
<li>In this way we can support 12 PWM outputs in case of J721E/J7200 simultaneously.</li>
</ul>
</li>
<li><b> Disadvantages: </b><ul>
<li>Each instance outputs are not independent. If frequency is changed for channel(EPWMxA) then it will be applied for 2nd channel also(EPWMxB).</li>
<li>Interrupt can be generated only for one of the event output either EPWMxA or EPWMxB since each instance has only one interrupt line.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="design_pwm_EPWM_dar_Channel_decision"></a>
Decision</h3>
<p>Typically in PWM use cases, it is recommended to have independent outputs so that you can control frequency, duty cycle and polarity can be independently. Even AUTOSAR provides API’s to change frequency independently for each channel. So option 1 is decided for implementation.</p>
<p>Some of the other hardware/driver specific decisions taken are listed below.</p><ul>
<li>If the default period is configured to zero during driver initialization, then the output shall be zero (zero percent duty-cycle).</li>
<li>Always UpDown Counter mode is selected to achieve symmetrical PWM output.</li>
<li>Interrupt notification is generated only for one of the event output either EPWMxA or EPWMxB, whichever is selected, since each instance has only one interrupt line.</li>
<li>If interface parameter outputCh is selected as EPWM_OUTPUT_CH_BOTH_A_AND_B then dual outputs of each instance will be available. i.e same EPWMxA output is also available in EPWMxB signal with same configured frequency, duty cycle and polarity. Interrupt notification is generated only for EPWMxA output if this option is selected.</li>
</ul>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="design_pwm_test_top"></a>
Test Criteria</h1>
<p>The sections below identify some of the aspects of design that would require emphasis during testing of this design implementation</p>
<ul>
<li><b> PWM Wave generation : Polarities </b><ul>
<li>Test cases shall check the generation of PWM wave based on different initial polarities configured. This will be verified on the CRO.</li>
</ul>
</li>
<li><b> PWM Wave generation : Duty Cycle, Period and Input clock frequency </b><ul>
<li>Test cases shall perform equivalence class test and ensure different duty cycles, periods for a PWM signal can be supported based on input clock frequencies.</li>
<li>Test cases should also check for conditions where the PWM parameters are reconfigured while the timer is running.</li>
</ul>
</li>
<li><b> PWM Wave generation :Reset (Period = 0) </b><ul>
<li>Test cases should check the behaviour on reset and with Period = 0</li>
</ul>
</li>
<li><b> PWM Multiple Instances </b><ul>
<li>Configure multiple PWM instances with duty cycle of 75% and 25%, reset and vary the duty cycles to ensure that the re-entrancy is maintained.</li>
</ul>
</li>
</ul>
<p><a class="el" href="design_pwm_top.html#design_pwm_intro">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="design_pwm_rev_hist"></a>
Document Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision  </th><th class="markdownTableHeadNone">Date  </th><th class="markdownTableHeadNone">Author  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Status   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.1  </td><td class="markdownTableBodyNone">25 Feb 2019  </td><td class="markdownTableBodyNone">Vibha Pant  </td><td class="markdownTableBodyNone">First version  </td><td class="markdownTableBodyNone">Pending Review   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.2  </td><td class="markdownTableBodyNone">26 Feb 2019  </td><td class="markdownTableBodyNone">Vibha Pant  </td><td class="markdownTableBodyNone">Review Comments Addressed  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.3  </td><td class="markdownTableBodyNone">8 Jul 2020  </td><td class="markdownTableBodyNone">Nikki Shah  </td><td class="markdownTableBodyNone">EPWM Addition  </td><td class="markdownTableBodyNone">Pending Review   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.4  </td><td class="markdownTableBodyNone">10 Jul 2020  </td><td class="markdownTableBodyNone">Nikki Shah  </td><td class="markdownTableBodyNone">Review Comments Addressed  </td><td class="markdownTableBodyNone">Loop for Review   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.5  </td><td class="markdownTableBodyNone">3 Nov 2020  </td><td class="markdownTableBodyNone">Nikki Shah  </td><td class="markdownTableBodyNone">Review Comments Addressed  </td><td class="markdownTableBodyNone">Approved   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="design_top.html">MCAL Module Design</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
