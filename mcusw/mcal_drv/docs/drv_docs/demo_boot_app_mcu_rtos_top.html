<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>MCUSW: CAN Response and Bootloader Demo Application</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCUSW
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('demo_boot_app_mcu_rtos_top.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">CAN Response and Bootloader Demo Application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="demo_boot_app_mcu_rtos_intro"></a>
Introduction</h1>
<hr/>
<p> This application demonstrates the fast boot capability provided by the Octal SPI flash controller on J721E &amp; J7200 SoCs. By default, it boots the main domain cores with basic applications, and also provides mechanisms to alternatively boot Linux or QNX on the MPU1_0 (i.e. A72) core. In addition, it demonstrates booting of the main domain cores via MMCSD media on J721E/J7200. The application performs the following actions:</p><ol type="1">
<li>MCAL Can driver is hosted on MCU1_0</li>
<li>Transmit a 64 byte CAN message, or, alternatively, run CAN profiling</li>
<li>Boot the main domain cores with a sample application image</li>
<li>Optionally, boots a HLOS (Linux, QNX) on the main domain MPU1_0</li>
</ol>
<p>This facilitates an early CAN response feature, typically required in an automotive ECU, followed by booting of the main domain cores on the SoC.</p>
<h2><a class="anchor" id="demo_boot_app_mcu_rtos_profiled"></a>
Performance / Early CAN response</h2>
<p>Please refer to the data sheets for early CAN response</p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_depend_int"></a>
Internal Dependencies</h2>
<p>This application depends on multiple components and are detailed in sections below</p><ol type="1">
<li>MCAL CAN Driver</li>
<li>MCAL BSW Stubs Stubs at <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcal_drv/mcal/Bsw_Stubs</em> are used. Functions CanIf_TxConfirmation () is required.</li>
<li>MCAL Configurations CAN &amp; DIO Configurations at <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/mcal_config</em> are used.</li>
</ol>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_depend_ext"></a>
External Dependencies</h2>
<p>This application depends on the <b>Secondary Boot Loader (SBL)</b> component from Processor SDK RTOS. For further details on the SBL, please refer to the Platform Development Kit (PDK) documentation on the SBL component for this release.</p>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_flowchart"></a>
Flow Charts</h1>
<p>The following flow chart displays the main application on the MCU1_0, which can spawn up to 2 current tasks.</p>
<div class="image">
<img src="canbootapp_main.png" alt="canbootapp_main.png"/>
<div class="caption">
MCU1_0 CAN and Bootloader Application</div></div>
<p>The following flow chart displays the functionality of the CAN task if the CAN function is set to "can_profiling".</p>
<div class="image">
<img src="demo_can_profile_flowchart.png" alt="demo_can_profile_flowchart.png"/>
<div class="caption">
MCU1_0 CAN Profiling Task</div></div>
<p>The following flow chart displays the functionality of the CAN task if the CAN function is set to "can_fast_response".</p>
<div class="image">
<img src="canbootapp_can_response_task.png" alt="canbootapp_can_response_task.png"/>
<div class="caption">
MCU1_0 CAN Response Task</div></div>
<p>The following flow chart displays the functionality of the Boot task, as well as the applications started on the main domain cores.</p>
<div class="image">
<img src="canbootapp_boot_task.png" alt="canbootapp_boot_task.png"/>
<div class="caption">
MCU1_0 Boot Task and Main Domain Applications</div></div>
<p>The following flow chart displays the functionality of the Boot task when run along with BIST (as well as the applications started on the main domain cores). Note that the default build of this application disables the BIST thread shown below, and BISTFUNC flag must be enabled in the build for BIST to be run.</p>
<div class="image">
<img src="canbootapp_boot_task_plus_bist.png" alt="canbootapp_boot_task_plus_bist.png"/>
<div class="caption">
MCU1_0 Boot Task with BIST and Main Domain Applications</div></div>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_cfg"></a>
Compile Time Configurations for Boot Application</h1>
<ol type="1">
<li><p class="startli">Enable/Disable Boot Task</p>
<p class="startli">The task that boots the main domain cores can be enabled/disabled. In the default boot sequence there are 3 stages for booting (J721E), or 2 stages (J7200). The specification of the cores to be included in each stage is given by the arrays "boot_order_first_stage", "boot_order_second_stage" and "boot_order_third_stage", found in mcuss_demos/boot_app_mcu_rtos/soc/$SOC/boot_core_defs.c. Below is the configuration flag for this feature.</p><ul>
<li>BOOTFUNC</li>
</ul>
<p class="startli">Options are "enabled" (default) or "disabled".</p>
</li>
<li><p class="startli">Enable/Disable BIST Task (J721E only) The task that runs Logic BIST and Memory BIST prior to boot stages can be enabled/disabled. In the default BIST sequence, there is one "pre-boot" stage (for BIST sections that need to be run before booting any of the main domain cores) and 3 main stages where BIST is run for main domain cores prior to the Boot Task booting those particular cores. The specification of the cores to be included in each stage is given by the arrays "pbist_pre_boot_stage", "lbist_pre_boot_stage", "pbist_first_boot_stage", "lbist_first_boot_stage", "pbist_second_boot_stage", "lbist_second_boot_stage", "pbist_third_boot_stage", and "lbist_third_boot_stage" in mcuss_demos/boot_app_mcu_rtos/soc/$SOC/bist_core_defs.c. Care should be taken to ensure that BIST sections defined for the 3 main stages (in bist_core_defs.c) match those utilized by the Boot Task (in boot_core_defs.c). Note that BOOTFUNC must be set to "enabled" as well to use the BIST Task. Below is the configuration flag for this feature.</p><ul>
<li>BISTFUNC</li>
</ul>
<p class="startli">Options are "enabled" or "disabled" (default).</p>
</li>
<li><p class="startli">Boot Media</p>
<p class="startli">The boot task can either boot the main domain cores using an appimage located in OSPI or on an MMCSD card. Below is the configuration flag for this feature.</p><ul>
<li>BOOTMODE</li>
</ul>
<p class="startli">Options are "ospi" (default) or "mmcsd".</p>
<p class="startli">Note that if the "ospi" option is utilized, the custom Secondary Boot Loader (sbl_cust_img) is expected to load the MCUSW Boot Application. If the "mmcsd" option is used, the mmcsd Secondary Boot Loader (sbl_mmcsd_img) should be used to load the MCUSW Boot Application.</p>
</li>
<li>Using DMA with OSPI Boot mode When using OSPI boot mode, this flash can be set, along with changes in the SBL "cust" build to enable OSPI DMA usage for loading images from the flash. Below is the configuration flag for this feature.<ul>
<li>ENABLE_OSPI_DMA Options are "no" (default) or "yes".</li>
</ul>
</li>
<li><p class="startli">Boot Operating Systems for MPU1_0</p>
<p class="startli">The boot task, by default, will load example applications written for TI Real-Time Operating System (RTOS) for all main domain cores (including MPU1_0). Alternatively, Linux or QNX operating systems could be loaded on MPU1_0. Below is the configuration flag for this feature.</p><ul>
<li>HLOSBOOT</li>
</ul>
<p class="startli">Options are "none" (default, which means MPU1_0 TI RTOS application is loaded), "qnx", or "linux".</p>
</li>
<li><p class="startli">CAN Functionality</p>
<p class="startli">The CAN task can either perform a fast CAN response, some CAN profiling over many messages, or be completely turned off. Below is the configuration flag for this feature.</p><ul>
<li>CANFUNC</li>
</ul>
<p class="startli">Options are "can_fast_response" (default), "can_profiling", or "none" (to completely disable the CAN task).</p>
</li>
</ol>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_can_cfg"></a>
Compile Time Configurations for CAN profiling / CAN fast response task</h1>
<ol type="1">
<li><p class="startli">Enable CAN transmit only mode</p>
<p class="startli">In transmit-only mode, messages can be received if an external CAN utility, like the CANOE tool or the PEAK tool, are connected to the EVM board. The J721E/J7200 EVM has four CAN ports: MCU_MCAN0, MCU_MCAN1, MCAN0 and MCAN2(J721E)/MCAN3(J7200). However, this demonstration only uses the first instance, MCU_MCAN0. Below are the configuration flags associated with this feature.</p><ul>
<li>CAN_LOOPBACK_ENABLE</li>
</ul>
<p class="startli">Enable/Disable internal loopback mode.</p>
<p class="startli">Options are "STD_ON" or "STD_OFF".</p>
<p class="startli">CAN loopback configuration is present at <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/mcal_config/Can_Demo_Cfg/output/generated/soc/$SOC/mcu1_0/include/Can_Cfg.h</em></p><ul>
<li>CAN_TX_ONLY_MODE</li>
</ul>
<p class="startli">Enable TX-only mode (vs. RX-only mode).</p>
<p class="startli">Options are "STD_ON" or "STD_OFF".</p>
<p class="startli">CAN TX only configuration is present at <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/can_resp.h</em> (if using CAN Response task) AND <em>mcuss_demos/boot_app_mcu_rtos/can_profile.h</em> (if using CAN Profile task)</p>
</li>
<li><p class="startli">Use first instance of CAN peripheral only</p>
<p class="startli">Saves boot time by using only the first instance (MCU_MCAN0) of the CAN peripheral configured. Below is the configuration.</p><ul>
<li>APP_INSTANCE_1_INST_IN_CFG_ONLY</li>
</ul>
<p class="startli">Use first instance of CAN peripheral only.</p>
<p class="startli">Options are "STD_ON" or "STD_OFF".</p>
<p class="startli">CAN configuration is present at <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/can_resp.h</em> (if using CAN Response task) AND <em>mcuss_demos/boot_app_mcu_rtos/can_profile.h</em> (if using CAN Profile task)</p>
</li>
<li><p class="startli">Disable early prints before CAN response</p>
<p class="startli">When testing for early CAN response, it is important to disable any early prints that may be taking extra time before the CAN response actually starts. Below is the configuration.</p><ul>
<li>CAN_INITIAL_PRINT_DISABLE_BEFORE_CAN_RESPONSE</li>
</ul>
<p class="startli">Enable this flag to minimize latencies due to early prints (disables the early prints).</p>
<p class="startli">Options are "STD_ON" or "STD_OFF".</p>
<p class="startli">CAN early prints configuration is present at <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/can_resp.h</em> (if using CAN Response task) AND <em>mcuss_demos/boot_app_mcu_rtos/can_profile.h</em> (if using CAN Profile task)</p>
</li>
</ol>
<h1>Customizing CAN response / CAN profiling examples</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">For TX Only  </th><th class="markdownTableHeadNone">Flag Value  </th><th class="markdownTableHeadNone">Location   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">APP_INSTANCE_1_INST_IN_CFG_ONLY  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_LOOPBACK_ENABLE  </td><td class="markdownTableBodyNone">STD_OFF  </td><td class="markdownTableBodyNone">mcuss_demos/mcal_config/Can_Demo_Cfg/output/generated/soc/$SOC/mcu1_0/include/Can_Cfg.h   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAN_TX_ONLY_MODE  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_INITIAL_PRINT_DISABLE_BEFORE_CAN_RESPONSE  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h (if desired, to reduce early latency in CAN response)   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Loopback  </th><th class="markdownTableHeadNone">Flag Value  </th><th class="markdownTableHeadNone">Location   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">APP_INSTANCE_1_INST_IN_CFG_ONLY  </td><td class="markdownTableBodyNone">STD_OFF  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_LOOPBACK_ENABLE  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/mcal_config/Can_Demo_Cfg/output/generated/soc/$SOC/mcu1_0/include/Can_Cfg.h   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAN_TX_ONLY_MODE  </td><td class="markdownTableBodyNone">X  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_INITIAL_PRINT_DISABLE_BEFORE_CAN_RESPONSE  </td><td class="markdownTableBodyNone">STD_OFF  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
</table>
<p>For instructions on how to measure early CAN response timing, see the <a class="el" href="demo_can_profile_top.html#demo_can_profile_early_can_res_j721e_j7200">Early CAN response on J721E/J7200 section</a>.</p>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_setup_cfg"></a>
Test Setup / Configurations used</h1>
<h2>Loopback mode</h2>
<ol type="1">
<li>Supported EVM / SoC <div class="image">
<img src="canbootapp_j721e_can_loopback_setup.png" alt="canbootapp_j721e_can_loopback_setup.png"/>
<div class="caption">
Loopback Setup</div></div>
</li>
</ol>
<h2>TX Only mode</h2>
<ol type="1">
<li>CAN_HIGH of all the nodes on the bus shall be connected together. Similary CAN_LOW of all the nodes on the bus shall be connected together. <div class="image">
<img src="canbootapp_j721e_can_tx_setup.png" alt="canbootapp_j721e_can_tx_setup.png"/>
<div class="caption">
TxOnly Setup</div></div>
</li>
</ol>
<div class="image">
<img src="canbootapp_j721e_can_tx_setup_closeup.png" alt="canbootapp_j721e_can_tx_setup_closeup.png"/>
<div class="caption">
TxOnly Setup - Closeup</div></div>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_prep_dep"></a>
Building dependent binaries</h1>
<p>We need have the following binaries built from <em>coresdk_rtos_jacinto_xx_yy_xx_bb</em>:</p><ol type="1">
<li><b>sbl_cust_img</b> that loads TIFS and initializes the OSPI flash. This SBL is used when utilizing MCUSW Boot App with BOOTMODE="ospi".</li>
<li><b>sbl_mmcsd_img</b> that loads TIFS, initializes the board, and copies the MCUSW Boot App image from the SD card to DDR memory. This SBL is used when utilizing MCUSW Boot App with BOOTMODE="mmcsd".</li>
</ol>
<p>Apart from the above binaries, we need to build the <b>can_boot_app_mcu_rtos</b> that the SBL copies from either OSPI flash or the SD card, and does the following:</p><ol type="1">
<li>CAN loopback / transmit</li>
<li>Boot the available main domain cores - J7200: MPU1_0, MCU2_0, MCU2_1; J721E: MPU1_0, MCU2_0, MCU2_1, MCU3_0, MCU3_1, C66X_0, C66X_1, C7X_0</li>
</ol>
<hr/>
 <h2>Building sbl_cust_img</h2>
<p>Go to <em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/build</em> and run the following w/ $board set to "j721e_evm" or "j7200_evm":</p>
<div class="fragment"><div class="line">make -j BOARD=$board CORE=mcu1_0 BUILD_PROFILE=release sbl_cust_img</div></div><!-- fragment --><p>OPTION for OSPI boot w/ DMA: If you plan to build the can_boot_app_mcu_rtos with ENABLE_OSPI_DMA=yes , then you need to make some corresponding changes in <b>sbl_cust_img</b> by modifying the CUST_SBL_TEST_FLAGS and some related makefile lines in the file <em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/boot/sbl/sbl_component.mk</em>. Make the following changes to these lines (with -DSBL_USE_DMA=1 and with SBL_USE_DMA=yes), and then do a clean build of sbl_lib_cust &amp; sbl_cust_img:</p>
<div class="fragment"><div class="line">CUST_SBL_TEST_FLAGS =&quot; -DSBL_USE_DMA=1 -DSBL_LOG_LEVEL=1 -DSBL_SCRATCH_MEM_START=0xB8000000 -DSBL_SCRATCH_MEM_SIZE=0x4000000 -DSBL_ENABLE_PLL -DSBL_ENABLE_CLOCKS -DSBL_ENABLE_DDR -DSBL_SKIP_MCU_RESET -DBOOT_OSPI&quot;</div><div class="line">...</div><div class="line"></div><div class="line">sbl_lib_cust_MAKEFILE = -f$(PDK_SBL_COMP_PATH)/build/sbl_lib.mk BOOTMODE=cust SBL_USE_DMA=yes CUST_SBL_FLAGS=$(CUST_SBL_TEST_FLAGS)</div><div class="line">...</div><div class="line"></div><div class="line">sbl_cust_img_MAKEFILE = -f$(PDK_SBL_COMP_PATH)/build/sbl_img.mk BOOTMODE=cust SBL_USE_DMA=yes BUILD_HS=no CUST_SBL_FLAGS=$(CUST_SBL_TEST_FLAGS)</div></div><!-- fragment --><p>NOTE: For Early CAN response with the fastest boot time (with NO prints enabled), you can pre-configure the SBL flags before building <b>sbl_cust_img</b> by modifying the CUST_SBL_TEST_FLAGS in the file <em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/boot/sbl/sbl_component.mk</em>. Just search for this line and un-comment it (and comment out similar lines above it), then save and build sbl_cust_img:</p>
<div class="fragment"><div class="line">#CUST_SBL_TEST_FLAGS =&quot; -DSBL_USE_DMA=0 -DSBL_LOG_LEVEL=1 -DSBL_SCRATCH_MEM_START=0x41cc0000 -DSBL_SCRATCH_MEM_SIZE=0x40000 -DSBL_ENABLE_PLL -DSBL_ENABLE_CLOCKS -DSBL_SKIP_MCU_RESET -DBOOT_OSPI -DSBL_ENABLE_DEV_GRP_MCU -DSBL_HLOS_OWNS_FLASH -DSBL_SKIP_PINMUX_ENABLE -DSBL_SKIP_LATE_INIT -DSBL_USE_MCU_DOMAIN_ONLY&quot;</div></div><!-- fragment --><hr/>
 <h2>Building sbl_mmcsd_img</h2>
<p>Go to <em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/build</em> and run the following w/ $board set to "j721e_evm" or "j7200_evm":</p>
<div class="fragment"><div class="line">make -j BOARD=$board CORE=mcu1_0 BUILD_PROFILE=release sbl_mmcsd_img</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_building_can_boot_app_mcu_rtos"></a>
Building can_boot_app_mcu_rtos</h2>
<p>Go to <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/build</em> and run the following w/ $board as "j721e_evm" or "j7200_evm" and with matching $soc as "j721e" or "j7200":</p>
<div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --><p>The default mode is OSPI boot and CAN fast response, with all main domain cores loaded with TI RTOS images.</p>
<p>Some common configurations also supported include:</p>
<p>For Early CAN response measurement (NO prints, and NO cores booted):</p>
<div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos BOOTFUNC=disabled BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos MCUSW_UART_ENABLE=false</div></div><!-- fragment --><p>Booting TI RTOS images from MMCSD (all TI RTOS images for main domain cores):</p>
<div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos BOOTMODE=mmcsd BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --><p>Booting HLOS on MPU1_0 with TI RTOS images on other main domain cores (OSPI mode):</p>
<div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=linux BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --> <div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=qnx BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --><p>Booting HLOS on MPU1_0 with TI RTOS images on other main domain cores (MMCSD mode):</p>
<div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=linux BOOTMODE=mmcsd BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --> <div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=qnx BOOTMODE=mmcsd BOARD=$board SOC=$soc BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --><p>The output appimage "can_boot_app_mcu_rtos_mcu1_0_release.appimage" will be placed in <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/$board</em> directory.</p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_building_main_domain_applications"></a>
Building main domain applications</h2>
<h3><a class="anchor" id="demo_boot_app_mcu_rtos_building_main_domain_applications_rtos"></a>
Creating RTOS appimage for main domain cores</h3>
<p>Go to <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/scripts</em> and run the following, with $board as "j721e_evm" or "j7200_evm": ./makemulticore.sh $board</p>
<p>After building all the binaries for each main domain core, this script calls the constructappimage_multistage.sh script to construct main-domain appimage files for loading the main domain cores, in three separate stages. The multi-stage appimage files will be utilized by the MCUSW boot application to load the main domain cores. <b>J721E</b>: the output appimage files "multicore_MCU2_0_MCU2_1_stage1.appimage", "multicore_DSPs_MCU3_0_MCU3_1_stage2.appimage", and "multicore_MPU1_0_stage3.appimage" will be placed in <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm</em> directory, and these appimage files contain binaries for the following cores: MPU1_0, MCU2_0, MCU2_1, MCU3_0, MCU3_1, C66X_0, C66X_1, C7X_0. <b>J7200</b>: the output appimage files "multicore_MCU2_0_MCU2_1_stage1.appimage" and "multicore_MPU1_0_stage2.appimage" will be placed in <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm</em> directory, and these appimage files contain binaries for the following cores: MPU1_0, MCU2_0, MCU2_1.</p>
<p>There is also a separate script, constructappimage_singlestage.sh, which can be used to combine all of the core images into a single appimage file, "multicore_split_with_DSPs.appimage", if it is desired to load all the main domain cores in a single stage. The contents of this appimage can be customized by slight modification of the script. This script contains some variables for the most-likely appimage cases in the main domain:</p><ol type="1">
<li><em>mpu_rtos_enabled</em> - This flag controls if the appimage will contain MPU1_0 binary or not. By default, this flag is set, and, thus, includes example RTOS MPU1_0 application. If Linux or QNX is instead desired on MPU1_0, this flag should be set to 0, and then re-run the constructappimage.sh.</li>
<li><em>split_mode</em> - This flag controls if main MCU's are run in split mode or not. If it is set to 0, the MCU2_1 and MCU3_1 images will be left out of the appimage. Note that the name of the generated output changes when disabling this flag.</li>
<li><em>dsp_binaries_included</em> - This flag control if C66 and C7 DSP binaries are included or not. Note that the name of the generated output changes when disabling this flag.</li>
</ol>
<p>Note that either constructappimage_multistage.sh or constructappimage_singlestage.sh could be utilized to formulate main-domain appimages with other binaries on each core. One could simply copy these ELF images to the <em>mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board</em> directory, and then modify the ElfImages, CoreRprcFiles, and CoreIds arrays within the script before running it.</p>
<h3><a class="anchor" id="demo_boot_app_mcu_rtos_building_main_domain_applications_hlos"></a>
Creating HLOS appimages for Linux or QNX</h3>
<p>In the common, alternative case where Linux/QNX is booted on MPU1_0, the following steps should be followed:</p><ol type="1">
<li>Rebuild the can_boot_app_mcu_rtos image with the <em>HLOSBOOT</em> flag set to either "linux" or "qnx", as described in the <a href="#demo_boot_app_mcu_rtos_building_can_boot_app_mcu_rtos">Building can_boot_app_mcu_rtos section</a>.</li>
<li>Go to the <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/scripts/hlos</em> directory and edit the constructappimageshlos.sh by setting the "OS" and Linux-specific or QNX-specific paths to match your setup. This assumes that the Linux/QNX binaries have already been created, as this script only creates appimages based off these already-created HLOS binaries.</li>
<li>After modifying the user-defined variables in the constructappimageshlos.sh script, run this script like this: ./constructappimagehlos.sh $board . If run correctly, the <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board</em> directory should now contain the following files:<ol type="a">
<li>For Linux - atf_optee.appimage, tidtb_linux.appimage, and tikernelimage_linux.appimage</li>
<li>For QNX - atf_optee.appimage and ifs_qnx.appimage</li>
</ol>
</li>
<li>NOTE: For booting the remaining MAIN domain cores (other than A72), you can simply reuse the RTOS images that were built in an earlier step in the binaries: "multicore_MCU2_0_MCU2_1_stage1.appimage" &amp; "multicore_DSPs_MCU3_0_MCU3_1_stage2.appimage"</li>
</ol>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_steps_2_run"></a>
Steps to run</h1>
<h2>Writing needed binaries to OSPI</h2>
<p>To run the default TI RTOS applications on all the main domain cores, flash the following binaries in OSPI memory at the respective offsets (in hex) as given below:</p>
<p><b>J721E</b>:</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/boot/sbl/binary/j721e_evm/cust/bin/sbl_cust_img_mcu1_0_release.tiimage</em> @ <b>0</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/drv/sciclient/soc/V1/tifs.bin</em> @ <b>80000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/j721e_evm/can_boot_app_mcu_rtos_mcu1_0_release.appimage</em> @ <b>100000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/multicore_MCU2_0_MCU2_1_stage1.appimage</em> @ <b>1fc0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/multicore_DSPs_MCU3_0_MCU3_1_stage2.appimage</em> @ <b>27c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/multicore_MPU1_0_stage3.appimage</em> @ <b>37c0000</b></li>
</ol>
<p>To alternatively boot Linux on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also flash the following binaries in OSPI memory at the respective offsets (in hex):</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/atf_optee.appimage</em> @ <b>1c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/tikernelimage_linux.appimage</em> @ <b>7c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/tidtb_linux.appimage</em> @ <b>1ec0000</b></li>
</ol>
<p>To alternatively boot QNX on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also flash the following binaries in OSPI memory at the respective offsets (in hex):</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/atf_optee.appimage</em> @ <b>1c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/ifs_qnx.appimage</em> @ <b>7c0000</b></li>
</ol>
<p>Note that, for Linux/QNX binaries, the can_boot_app_mcu_rtos_mcu1_0_release.appimage will also need to be rebuilt, as described in <a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_hlos">Creating HLOS appimages for Linux or QNX</a>, and redownloaded to the designated OSPI location above. For booting the remaining MAIN domain cores (other than A72), you can simply reuse the RTOS images that were built in an earlier step in the binaries: "multicore_MCU2_0_MCU2_1_stage1.appimage" &amp; "multicore_DSPs_MCU3_0_MCU3_1_stage2.appimage".</p>
<p><b>J7200</b>:</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/boot/sbl/binary/j7200_evm/cust/bin/sbl_cust_img_mcu1_0_release.tiimage</em> @ <b>0</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/drv/sciclient/soc/V2/tifs.bin</em> @ <b>80000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/j7200_evm/can_boot_app_mcu_rtos_mcu1_0_release.appimage</em> @ <b>100000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/multicore_MCU2_0_MCU2_1_stage1.appimage</em> @ <b>1fc0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/multicore_MPU1_0_stage2.appimage</em> @ <b>27c0000</b></li>
</ol>
<p>To alternatively boot Linux on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also flash the following binaries in OSPI memory at the respective offsets (in hex):</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/atf_optee.appimage</em> @ <b>1c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/tikernelimage_linux.appimage</em> @ <b>7c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/tidtb_linux.appimage</em> @ <b>1ec0000</b></li>
</ol>
<p>To alternatively boot QNX on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also flash the following binaries in OSPI memory at the respective offsets (in hex):</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/atf_optee.appimage</em> @ <b>1c0000</b></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/ifs_qnx.appimage</em> @ <b>7c0000</b></li>
</ol>
<p>Note that, for Linux/QNX binaries, the can_boot_app_mcu_rtos_mcu1_0_release.appimage will also need to be rebuilt, as described in <a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_hlos">Creating HLOS appimages for Linux or QNX</a>, and redownloaded to the designated OSPI location above. For booting the remaining MAIN domain cores (other than A72), you can simply reuse the RTOS images that were built in an earlier step in the binary: "multicore_MCU2_0_MCU2_1_stage1.appimage".</p>
<p>Refer <a href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Uniflash Programming Guide</a> to learn how to program the binaries at the respective offset in the flash.</p>
<h2>Writing needed binaries to MMCSD</h2>
<p>To run the default TI RTOS applications on all the main domain cores, copy the following binaries onto the MMCSD card:</p>
<ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/boot/sbl/binary/$board/cust/bin/sbl_mmcsd_img_mcu1_0_release.tiimage</em>, rename to <em>tiboot3.bin</em></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/pdk_jacinto_07.x.x/packages/ti/drv/sciclient/soc/V1/tifs.bin</em> (for J721E), or *../V2/tifs.bin* (for J7200)</li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/$board/can_boot_app_mcu_rtos_mcu1_0_release.appimage</em>, rename to <em>app</em></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/&lt;board/multicore_MCU2_0_MCU2_1_stage1.appimage</em>, rename to <em>lateapp1</em></li>
<li>J7200: <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j7200_evm/multicore_MPU1_0_stage2.appimage</em>, rename to <em>lateapp2</em></li>
<li>J721E: <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/&lt;j721e_evm/multicore_DSPs_MCU3_0_MCU3_1_stage2.appimage</em>, rename to <em>lateapp2</em></li>
<li>J721E: <em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/multicore_MPU1_0_stage3.appimage</em>, rename to <em>lateapp3</em></li>
</ol>
<p>To alternatively boot Linux on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also copy the following binaries onto the MMCSD card:</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board/atf_optee.appimage</em></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board/tidtb_linux.appimage</em></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board/tikernelimage_linux.appimage</em></li>
</ol>
<p>To alternatively boot QNX on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also copy the following binaries onto the MMCSD card:</p><ol type="1">
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board/atf_optee.appimage</em></li>
<li><em>coresdk_rtos_jacinto_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/$board/ifs_qnx.appimage</em></li>
</ol>
<p>Note that, for Linux/QNX binaries, the can_boot_app_mcu_rtos_mcu1_0_release.appimage will also need to be rebuilt, as described in <a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_hlos">Creating HLOS appimages for Linux or QNX</a>, and copied again to the MMCSD card. For booting the remaining MAIN domain cores (other than A72), you can simply reuse the RTOS images that were built in an earlier step in the binaries: "multicore_MCU2_0_MCU2_1_stage1.appimage" &amp; "multicore_DSPs_MCU3_0_MCU3_1_stage2.appimage".</p>
<h2>Running the demonstration</h2>
<ol type="1">
<li>Ensure boot mode of the EVM is configured as described in (<a class="el" href="mcusw_c_ug_top.html#mcusw_depend_evm_j721e_mmcsd">J721E/J7200/J721S2 EVM MMC/SD Boot Mode</a>) or (<a class="el" href="mcusw_c_ug_top.html#mcusw_depend_evm_j721e_ospi">J721E/J7200 EVM OSPI Boot Mode</a>)</li>
<li>UART / Console for demo application logs / messages<ul>
<li>J721E/J7200 EVM has 2 UART ports</li>
<li>UART port named <b> MCU UART </b> would be used when demo applications are hosted on MCU R5F (e.g. MCU1_0)</li>
<li>UART port named <b> UART </b> would be used when demo applications are hosted on MAIN R5F (e.g. MCU2_1, etc.)</li>
<li>Refer EVM Image at (<a class="el" href="mcusw_c_ug_top.html#mcusw_depend_evm_j721e">J721E EVM</a>)</li>
</ul>
</li>
<li>Connect two separate micro USB cables between MCU UART port (J43) &lt;==&gt; host PC and Main UART port (J44) &lt;==&gt; host PC</li>
<li>Configure two separate instances of a serial console application on host PC to use MCU UART port, channel #2 (i.e. second UART instance) and Main UART port, channel #2 (i.e. fourth UART instance), respectively. For each instance, use a '115200 8N1' configuration.<ol type="a">
<li>If also testing Linux/QNX booting, also configure Main UART port, channel #1 (i.e. third UART instance) with a similar '115200 8N1' configuration.</li>
</ol>
</li>
<li>Power ON the board and confirm the boot logs on serial console</li>
</ol>
<p>After the application has completed, the UART logs are contained on the following UART ports:</p><ol type="1">
<li>MCU UART port, channel #2 (i.e. second UART instance) - MCU R5F CAN Boot Application logs</li>
<li>Main UART port, channel #1 (i.e. third UART instance) - Linux/QNX boot logs (only if Linux/QNX build enabled)</li>
<li>Main UART port, channel #2 (i.e. fourth UART instance) - Main Domain RTOS application logs</li>
</ol>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_main_domain_rtos_can_output_loopback"></a>
Sample output RTOS main domain apps, CAN Loop back mode</h2>
<p>Below is the log for CAN Boot App (J721E) when CAN is configured in loop-back mode, and all main domain cores run the RTOS example application (OSPI boot mode).</p>
<p>MCU UART Port#2 (second UART port on PC): </p><pre class="fragment">CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000c0 Message Length is 64
CAN Response App:Test completed for 0 instance

CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000b0 Message Length is 64
CAN Response App:Test completed for 1 instance

C OSPI NOR device ID: 0x5b1a, manufacturer ID: 0xCAN Response App: 8192 bytes used for stack
CAN Response App: 8192 bytes used for stack
CAN Response App:Early CAN completed!!!
Boot App: Started at 347 usec
Boot App: Total Num booted cores = 8
Boot App: Booted Core ID #6 at 294663 usecs
Boot App: Booted Core ID #7 at 294937 usecs
Boot App: Booted Core ID #8 at 311442 usecs
Boot App: Booted Core ID #9 at 311717 usecs
Boot App: Booted Core ID #10 at 312044 usecs
Boot App: Booted Core ID #11 at 312372 usecs
Boot App: Booted Core ID #12 at 312807 usecs
Boot App: Booted Core ID #0 at 319346 usecs

MCU Boot Task started at 345 usecs and finished at 1931335 usecs
</pre><p>Main UART Port#2 (fourth UART port on PC): </p><pre class="fragment">MPU1_0 started running at 331942 usecs
MPU1_0 initialized at 332201 usecs
MCU2_0 started running at 349214 usecs
MCU2_0 initialized at 350583 usecs
MCU2_1 started running at 349576 usecs
MCU2_1 initialized at 350947 usecs
MCU3_0 started running at 366498 usecs
MCU3_0 initialized at 367807 usecs
MCU3_1 started running at 366748 usecs
MCU3_1 initialized at 368070 usecs
C7X_0 started running at 332874 usecs
C7X_0 initialized at 333038 usecs
C66X_0 started running at 342547 usecs
C66X_0 initialized at 343780 usecs
C66X_1 started running at 343237 usecs
C66X_1 initialized at 344200 usecs
</pre><p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_main_domain_rtos_qnx_can_output_loopback"></a>
Sample output RTOS main domain apps with QNX, CAN Loop back mode</h2>
<p>Below is the log for CAN Boot App (J721E) when CAN is configured in loop-back mode, and all main domain cores run the RTOS example application (OSPI boot mode), except for MPU1_0 running QNX.</p>
<p>MCU UART Port#2 (second UART port on PC): </p><pre class="fragment">CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000c0 Message Length is 64
CAN Response App:Test completed for 0 instance

CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000b0 Message Length is 64
CAN Response App:Test completed for 1 instance

CAN Response App: 8192 bytes used for stack
CAN Response App:Early CAN completed!!!
OSPI flash left configured in Legacy SPI mode.

 OSPI NOR device ID: 0x5b1a, manufacturer ID: 0x2c
Boot App: Started at 347 usec
Boot App: Total Num booted cores = 8
Boot App: Booted Core ID #6 at 294667 usecs
Boot App: Booted Core ID #7 at 294942 usecs
Boot App: Booted Core ID #8 at 311390 usecs
Boot App: Booted Core ID #9 at 311664 usecs
Boot App: Booted Core ID #10 at 311991 usecs
Boot App: Booted Core ID #11 at 312315 usecs
Boot App: Booted Core ID #12 at 312755 usecs
Boot App: Booted Core ID #0 at 572087 usecs

MCU Boot Task started at 346 usecs and finished at 2117335 usecs
</pre><p>Main UART Port#1 (third UART port on PC): </p><pre class="fragment">NOTICE:  BL31: v2.2(debug):ti2019.06-rc5
NOTICE:  BL31: Built : 09:20:36, Feb 12 2020
INFO:    GICv3 without legacy support detected. ARM GICv3 driver initialized in EL3
INFO:    SYSFW ABI: 3.0 (firmware rev 0x0014 '20.04.1-v2020.04a (Terrific Lla')
INFO:    BL31: Initializing runtime services
INFO:    BL31: cortex_a72: CPU workaround for cve_2018_3639 was applied
INFO:    BL31: Initializing BL32
I/TC:
I/TC: OP-TEE version: ti2019.06-rc5 (gcc version 8.3.0 (GNU Toolchain for the A-profile Architecture 8.3-2019.03 (arm-rel-8.36))) #3 Thu Jan 30 16:40:38 UTC 2020 aarch64
I/TC: Initialized
INFO:    BL31: Preparing for EL3 exit to normal world
INFO:    Entry point address = 0x80080000
INFO:    SPSR = 0x3c9
MMU: 16-bit ASID 44-bit PA TCR_EL1=b5183519
cpu0: MPIDR=80000000
cpu0: MIDR=411fd080 Cortex-A72 r1p0
cpu0: CWG=4 ERG=4 Dminline=4 Iminline=4 PIPT
cpu0: CLIDR=a200023 LoUU=1 LoC=2 LoUIS=1
cpu0: L1 Icache 48K linesz=64 set/way=256/3
cpu0: L1 Dcache 32K linesz=64 set/way=256/2
cpu0: L2 Unified 1024K linesz=64 set/way=1024/16
Loading IFS...done
cpu1: MPIDR=80000001
cpu1: MIDR=411fd080 Cortex-A72 r1p0
cpu1: CWG=4 ERG=4 Dminline=4 Iminline=4 PIPT
cpu1: CLIDR=a200023 LoUU=1 LoC=2 LoUIS=1
cpu1: L1 Icache 48K linesz=64 set/way=256/3
cpu1: L1 Dcache 32K linesz=64 set/way=256/2
cpu1: L2 Unified 1024K linesz=64 set/way=1024/16

System page at phys:0000000080011000 user:ffffff8040252000 kern:ffffff8040251000
Starting next program at vffffff8060058ae0
MMFLAGS=1
All ClockCycles offsets within tolerance
Welcome to QNX Neutrino 7.0 on TI J721E EVM Board!!
start serial driver
Toggle GPIO_uSD_PWR_EN for uSD
data: ch c2h
data: 4h c2h
data: 4h c6h
data: ch c6h
data: 4h ceh
data: 7h fch
MASTER_SEND: Input/output error
Setting environment variables...
done..
Looking for user script to run: /sd/user.sh
Unable to access /sd/stage/user.sh
done...
J7EVM#
</pre><p>Main UART Port#2 (fourth UART port on PC): </p><pre class="fragment">MCU2_0 started running at 349013 usecs
MCU2_0 initialized at 350403 usecs
MCU2_1 started running at 349377 usecs
MCU2_1 initialized at 350787 usecs
MCU3_0 started running at 367257 usecs
MCU3_0 initialized at 368619 usecs
MCU3_1 started running at 367538 usecs
MCU3_1 initialized at 368904 usecs
C7X_0 started running at 332980 usecs
C7X_0 initialized at 333144 usecs
C66X_0 started running at 342690 usecs
C66X_0 initialized at 343960 usecs
C66X_1 started running at 343404 usecs
C66X_1 initialized at 344470 usecs
</pre><p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_known_issues"></a>
Known Issues</h1>
<ol type="1">
<li>When booting QNX on MPU1_0 from MMCSD, the reading of the IFS (QNX) image is not optimized for MMCSD. Thus, the start of the booting of QNX may not happen until about 8-10 seconds after the MCUSW CAN Boot App has started. Note that customers are encouraged to utilize OSPI boot media to get best startup times.</li>
</ol>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_rev_history"></a>
Document Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision  </th><th class="markdownTableHeadNone">Date  </th><th class="markdownTableHeadNone">Author  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Status   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.1  </td><td class="markdownTableBodyNone">16 Apr 2019  </td><td class="markdownTableBodyNone">Somnath  </td><td class="markdownTableBodyNone">Initial Version  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.2  </td><td class="markdownTableBodyNone">8 Aug 2019  </td><td class="markdownTableBodyNone">Sunil M S  </td><td class="markdownTableBodyNone">Updates logs for release 00.09.01  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.3  </td><td class="markdownTableBodyNone">30 Jan 2020  </td><td class="markdownTableBodyNone">Danny Jochelson  </td><td class="markdownTableBodyNone">New Version For TIRTOS Boot App  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.4  </td><td class="markdownTableBodyNone">4 Feb 2020  </td><td class="markdownTableBodyNone">Jonathan Bergsagel  </td><td class="markdownTableBodyNone">Updated for CAN boot app CAN response compile options  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.5  </td><td class="markdownTableBodyNone">17 Feb 2020  </td><td class="markdownTableBodyNone">Sujith S  </td><td class="markdownTableBodyNone">Re Organized the document  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">28 May 2020  </td><td class="markdownTableBodyNone">Jonathan Bergsagel  </td><td class="markdownTableBodyNone">Updated CAN boot app instructions for 7.0 SDK release  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.7  </td><td class="markdownTableBodyNone">22 Sept 2020  </td><td class="markdownTableBodyNone">Danny Jochelson  </td><td class="markdownTableBodyNone">Updated CAN boot app to include BIST task, Updated Boot Task to show staged image parsing  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.8  </td><td class="markdownTableBodyNone">4 Nov 2020  </td><td class="markdownTableBodyNone">Jonathan Bergsagel  </td><td class="markdownTableBodyNone">Updated instructions to include J7200 support, and new OSPI flash memory layout for images  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.9  </td><td class="markdownTableBodyNone">17 Nov 2020  </td><td class="markdownTableBodyNone">Jonathan Bergsagel  </td><td class="markdownTableBodyNone">Removed prior issue on booting Linux. Boot App enables an optimized Linux boot flow  </td><td class="markdownTableBodyNone">Approved   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="demo_top.html">MCUSS Demo Applications</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
