<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>MCUSW Datasheet: Ethernet Driver API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCUSW Datasheet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__MCAL__ETH__API.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Sub Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ethernet Driver API</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>The Ethernet Driver provides low-level access to the two-port Gigabit Ethernet Switch (MCU_CPSW0) hardware in the Jacinto 7 family. The first port (Port 0) is called host port and has a CPPI interface that interconnects the CPSW peripheral with the rest of the SoC. The second port (Port 1) is a MAC port which can be configured in RGMII or RMII mode.</p>
<p>The Ethernet Driver implements the standardized interface described in the AUTOSAR Release 4.2.1 Specification of the Ethernet Driver (AUTOSAR_SWS_EthDriver, Document ID 430).</p>
<p>The Ethernet Driver is part of the Communication Stack in the AUTOSAR Basic Software (BSW).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MCAL__ETH__CFG.html">Eth Configuration</a> </dd>
<dd>
<a class="el" href="group__MCAL__ETH__IRQ.html">Eth Driver Interrupt Handlers</a> </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Sub Modules</h2></td></tr>
<tr class="memitem:group__MCAL__ETH__CFG"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__CFG.html">Eth Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__MCAL__ETH__IRQ"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__IRQ.html">Eth Driver Interrupt Handlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5d7a2ab7987412f33d9f36f24216a656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga5d7a2ab7987412f33d9f36f24216a656">Eth_Init</a> (const Eth_ConfigType *CfgPtr)</td></tr>
<tr class="memdesc:ga5d7a2ab7987412f33d9f36f24216a656"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the driver.  <a href="#ga5d7a2ab7987412f33d9f36f24216a656">More...</a><br /></td></tr>
<tr class="separator:ga5d7a2ab7987412f33d9f36f24216a656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad3ee03f3ca94dca5190fe13fb7513d"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga6ad3ee03f3ca94dca5190fe13fb7513d">Eth_ControllerInit</a> (uint8 CtrlIdx, uint8 CfgIdx)</td></tr>
<tr class="memdesc:ga6ad3ee03f3ca94dca5190fe13fb7513d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the indexed controller.  <a href="#ga6ad3ee03f3ca94dca5190fe13fb7513d">More...</a><br /></td></tr>
<tr class="separator:ga6ad3ee03f3ca94dca5190fe13fb7513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07088f1594c14ef1d9b5ad0a52bad477"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga07088f1594c14ef1d9b5ad0a52bad477">Eth_SetControllerMode</a> (uint8 CtrlIdx, Eth_ModeType CtrlMode)</td></tr>
<tr class="memdesc:ga07088f1594c14ef1d9b5ad0a52bad477"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables / disables the indexed controller.  <a href="#ga07088f1594c14ef1d9b5ad0a52bad477">More...</a><br /></td></tr>
<tr class="separator:ga07088f1594c14ef1d9b5ad0a52bad477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eff360823a9ae54087b9276f59befe5"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga9eff360823a9ae54087b9276f59befe5">Eth_GetControllerMode</a> (uint8 CtrlIdx, Eth_ModeType *CtrlModePtr)</td></tr>
<tr class="memdesc:ga9eff360823a9ae54087b9276f59befe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the state of the indexed controller.  <a href="#ga9eff360823a9ae54087b9276f59befe5">More...</a><br /></td></tr>
<tr class="separator:ga9eff360823a9ae54087b9276f59befe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc915c5b06fd70c6c90d6fe16d22b05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gaafc915c5b06fd70c6c90d6fe16d22b05">Eth_GetPhysAddr</a> (uint8 CtrlIdx, uint8 *PhysAddrPtr)</td></tr>
<tr class="memdesc:gaafc915c5b06fd70c6c90d6fe16d22b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the physical source address used by the indexed controller.  <a href="#gaafc915c5b06fd70c6c90d6fe16d22b05">More...</a><br /></td></tr>
<tr class="separator:gaafc915c5b06fd70c6c90d6fe16d22b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1912a1d30eba82b7ce6914ceb0b016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga3c1912a1d30eba82b7ce6914ceb0b016">Eth_SetPhysAddr</a> (uint8 CtrlIdx, const uint8 *PhysAddrPtr)</td></tr>
<tr class="memdesc:ga3c1912a1d30eba82b7ce6914ceb0b016"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the physical source address used by the indexed controller.  <a href="#ga3c1912a1d30eba82b7ce6914ceb0b016">More...</a><br /></td></tr>
<tr class="separator:ga3c1912a1d30eba82b7ce6914ceb0b016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b628ac4bd732ae11172ea9eb3b46747"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga6b628ac4bd732ae11172ea9eb3b46747">Eth_UpdatePhysAddrFilter</a> (uint8 CtrlIdx, uint8 *PhysAddrPtr, Eth_FilterActionType Action)</td></tr>
<tr class="memdesc:ga6b628ac4bd732ae11172ea9eb3b46747"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the physical source address to / from the indexed controller filter.  <a href="#ga6b628ac4bd732ae11172ea9eb3b46747">More...</a><br /></td></tr>
<tr class="separator:ga6b628ac4bd732ae11172ea9eb3b46747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e74f407c48ef5e1a80b9d1fb33b192"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gad1e74f407c48ef5e1a80b9d1fb33b192">Eth_WriteMii</a> (uint8 CtrlIdx, uint8 TrcvIdx, uint8 RegIdx, uint16 RegVal)</td></tr>
<tr class="memdesc:gad1e74f407c48ef5e1a80b9d1fb33b192"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures a transceiver register or triggers a function offered by the receiver Service.  <a href="#gad1e74f407c48ef5e1a80b9d1fb33b192">More...</a><br /></td></tr>
<tr class="separator:gad1e74f407c48ef5e1a80b9d1fb33b192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a27206034ea65456d8ad4cbf5d4b19"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gab0a27206034ea65456d8ad4cbf5d4b19">Eth_ReadMii</a> (uint8 CtrlIdx, uint8 TrcvIdx, uint8 RegIdx, uint16 *RegValPtr)</td></tr>
<tr class="memdesc:gab0a27206034ea65456d8ad4cbf5d4b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a transceiver register.  <a href="#gab0a27206034ea65456d8ad4cbf5d4b19">More...</a><br /></td></tr>
<tr class="separator:gab0a27206034ea65456d8ad4cbf5d4b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20283f2c687eb8dcfddcc3e1ac6da1db"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga20283f2c687eb8dcfddcc3e1ac6da1db">Eth_GetDropCount</a> (uint8 CtrlIdx, uint8 CountValues, uint32 *DropCount)</td></tr>
<tr class="memdesc:ga20283f2c687eb8dcfddcc3e1ac6da1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a list with drop counter values of the corresponding controller.  <a href="#ga20283f2c687eb8dcfddcc3e1ac6da1db">More...</a><br /></td></tr>
<tr class="separator:ga20283f2c687eb8dcfddcc3e1ac6da1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a8c0e8c5fa8b44fade2183959e629f"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga94a8c0e8c5fa8b44fade2183959e629f">Eth_GetEtherStats</a> (uint8 CtrlIdx, uint32 *etherStats)</td></tr>
<tr class="memdesc:ga94a8c0e8c5fa8b44fade2183959e629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a list with statistics values of the corresponding controller.  <a href="#ga94a8c0e8c5fa8b44fade2183959e629f">More...</a><br /></td></tr>
<tr class="separator:ga94a8c0e8c5fa8b44fade2183959e629f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcb0a770ebf39f85a98d650b2c54284"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga8dcb0a770ebf39f85a98d650b2c54284">Eth_GetCurrentTime</a> (uint8 CtrlIdx, Eth_TimeStampQualType *timeQualPtr, Eth_TimeStampType *timeStampPtr)</td></tr>
<tr class="memdesc:ga8dcb0a770ebf39f85a98d650b2c54284"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a time value out of the HW registers.  <a href="#ga8dcb0a770ebf39f85a98d650b2c54284">More...</a><br /></td></tr>
<tr class="separator:ga8dcb0a770ebf39f85a98d650b2c54284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79cf00bdd342e92f173f8599e8b1453f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga79cf00bdd342e92f173f8599e8b1453f">Eth_EnableEgressTimeStamp</a> (uint8 CtrlIdx, uint8 BufIdx)</td></tr>
<tr class="memdesc:ga79cf00bdd342e92f173f8599e8b1453f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function activates egress time stamping on a dedicated message object.  <a href="#ga79cf00bdd342e92f173f8599e8b1453f">More...</a><br /></td></tr>
<tr class="separator:ga79cf00bdd342e92f173f8599e8b1453f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ff2195591d889199664c70aba6fd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga55ff2195591d889199664c70aba6fd76">Eth_GetEgressTimeStamp</a> (uint8 CtrlIdx, uint8 BufIdx, Eth_TimeStampQualType *timeQualPtr, Eth_TimeStampType *timeStampPtr)</td></tr>
<tr class="memdesc:ga55ff2195591d889199664c70aba6fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads back the egress time stamp on a dedicated message object.  <a href="#ga55ff2195591d889199664c70aba6fd76">More...</a><br /></td></tr>
<tr class="separator:ga55ff2195591d889199664c70aba6fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399e79b1dffaa1e84695d49dc3aeb10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga399e79b1dffaa1e84695d49dc3aeb10e">Eth_GetIngressTimeStamp</a> (uint8 CtrlIdx, Eth_DataType *DataPtr, Eth_TimeStampQualType *timeQualPtr, Eth_TimeStampType *timeStampPtr)</td></tr>
<tr class="memdesc:ga399e79b1dffaa1e84695d49dc3aeb10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads back the ingress time stamp on a dedicated message object.  <a href="#ga399e79b1dffaa1e84695d49dc3aeb10e">More...</a><br /></td></tr>
<tr class="separator:ga399e79b1dffaa1e84695d49dc3aeb10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4554c1750edbc367785498ccf1e4cf32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga4554c1750edbc367785498ccf1e4cf32">Eth_SetCorrectionTime</a> (uint8 CtrlIdx, Eth_TimeIntDiffType *timeOffsetPtr, Eth_RateRatioType *rateRatioPtr)</td></tr>
<tr class="memdesc:ga4554c1750edbc367785498ccf1e4cf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the Time Slave to adjust the local ETH Reference clock in HW.  <a href="#ga4554c1750edbc367785498ccf1e4cf32">More...</a><br /></td></tr>
<tr class="separator:ga4554c1750edbc367785498ccf1e4cf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1237ff1adbac0e4e3fc343ee8fd5ab70"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga1237ff1adbac0e4e3fc343ee8fd5ab70">Eth_SetGlobalTime</a> (uint8 CtrlIdx, Eth_TimeStampType *timeStampPtr)</td></tr>
<tr class="memdesc:ga1237ff1adbac0e4e3fc343ee8fd5ab70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the Time Master to adjust the global ETH Reference clock in HW.  <a href="#ga1237ff1adbac0e4e3fc343ee8fd5ab70">More...</a><br /></td></tr>
<tr class="separator:ga1237ff1adbac0e4e3fc343ee8fd5ab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga334c1e16b3010fb7bd65c0197bf91c1f"><td class="memItemLeft" align="right" valign="top">BufReq_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga334c1e16b3010fb7bd65c0197bf91c1f">Eth_ProvideTxBuffer</a> (uint8 CtrlIdx, Eth_BufIdxType *BufIdxPtr, uint8 **BufPtr, uint16 *LenBytePtr)</td></tr>
<tr class="memdesc:ga334c1e16b3010fb7bd65c0197bf91c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides access to a transmit buffer of the specified controller.  <a href="#ga334c1e16b3010fb7bd65c0197bf91c1f">More...</a><br /></td></tr>
<tr class="separator:ga334c1e16b3010fb7bd65c0197bf91c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770639a1e024f8d2b10b0789dc4f0a8c"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga770639a1e024f8d2b10b0789dc4f0a8c">Eth_Transmit</a> (uint8 CtrlIdx, Eth_BufIdxType BufIdx, Eth_FrameType FrameType, boolean TxConfirmation, uint16 LenByte, uint8 *PhysAddrPtr)</td></tr>
<tr class="memdesc:ga770639a1e024f8d2b10b0789dc4f0a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function triggers transmission of a previously filled transmit buffer.  <a href="#ga770639a1e024f8d2b10b0789dc4f0a8c">More...</a><br /></td></tr>
<tr class="separator:ga770639a1e024f8d2b10b0789dc4f0a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30f3fd7b78c5b59a4a8d25b713af82f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gad30f3fd7b78c5b59a4a8d25b713af82f">Eth_Receive</a> (uint8 CtrlIdx, Eth_RxStatusType *RxStatusPtr)</td></tr>
<tr class="memdesc:gad30f3fd7b78c5b59a4a8d25b713af82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function triggers frame reception.  <a href="#gad30f3fd7b78c5b59a4a8d25b713af82f">More...</a><br /></td></tr>
<tr class="separator:gad30f3fd7b78c5b59a4a8d25b713af82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8c58041c5362473af2f3799c046710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gafc8c58041c5362473af2f3799c046710">Eth_TxConfirmation</a> (uint8 CtrlIdx)</td></tr>
<tr class="memdesc:gafc8c58041c5362473af2f3799c046710"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function triggers frame transmission confirmation.  <a href="#gafc8c58041c5362473af2f3799c046710">More...</a><br /></td></tr>
<tr class="separator:gafc8c58041c5362473af2f3799c046710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6f59fd237df42d1f5ee35fe4cea29f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga9d6f59fd237df42d1f5ee35fe4cea29f">Eth_GetVersionInfo</a> (Std_VersionInfoType *VersionInfo)</td></tr>
<tr class="memdesc:ga9d6f59fd237df42d1f5ee35fe4cea29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the version information of this module.  <a href="#ga9d6f59fd237df42d1f5ee35fe4cea29f">More...</a><br /></td></tr>
<tr class="separator:ga9d6f59fd237df42d1f5ee35fe4cea29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4bf643bb9beec0e0eeb47d967e9af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gacb4bf643bb9beec0e0eeb47d967e9af5">Eth_MainFunction</a> (void)</td></tr>
<tr class="memdesc:gacb4bf643bb9beec0e0eeb47d967e9af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function checks for controller errors and lost frames. Used for polling state changes. Calls EthIf_CtrlModeIndication when the controller mode changed.  <a href="#gacb4bf643bb9beec0e0eeb47d967e9af5">More...</a><br /></td></tr>
<tr class="separator:gacb4bf643bb9beec0e0eeb47d967e9af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fe65a654aca3d95e102cef647e39aa"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gab7fe65a654aca3d95e102cef647e39aa">Eth_DispatchVirtmacInit</a> (uint8 CtrlIdx)</td></tr>
<tr class="memdesc:gab7fe65a654aca3d95e102cef647e39aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac initialization request to ethernet firmware.  <a href="#gab7fe65a654aca3d95e102cef647e39aa">More...</a><br /></td></tr>
<tr class="separator:gab7fe65a654aca3d95e102cef647e39aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ecedc4d3977b62368b624aa68dc591"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gad8ecedc4d3977b62368b624aa68dc591">Eth_DispatchVirtmacDeinit</a> (uint8 CtrlIdx)</td></tr>
<tr class="memdesc:gad8ecedc4d3977b62368b624aa68dc591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac deinit request to ethernet firmware.  <a href="#gad8ecedc4d3977b62368b624aa68dc591">More...</a><br /></td></tr>
<tr class="separator:gad8ecedc4d3977b62368b624aa68dc591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5e44bc25472b2e6bf18890565f3801"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gafa5e44bc25472b2e6bf18890565f3801">Eth_NotifyVirtmacMsgReceived</a> (uint8 CtrlIdx)</td></tr>
<tr class="memdesc:gafa5e44bc25472b2e6bf18890565f3801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify Ethernet driver that a RPC msg has been received from ethernet firmware.  <a href="#gafa5e44bc25472b2e6bf18890565f3801">More...</a><br /></td></tr>
<tr class="separator:gafa5e44bc25472b2e6bf18890565f3801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d5aa2dfeaa6eeceefaf7001070f336"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga21d5aa2dfeaa6eeceefaf7001070f336">Eth_DispatchVirtmacSubscribeAllTraffic</a> (uint8 CtrlIdx)</td></tr>
<tr class="memdesc:ga21d5aa2dfeaa6eeceefaf7001070f336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac all traffic subscription request to ethernet firmware.  <a href="#ga21d5aa2dfeaa6eeceefaf7001070f336">More...</a><br /></td></tr>
<tr class="separator:ga21d5aa2dfeaa6eeceefaf7001070f336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d981aef567cc661a4632e52555d7937"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga1d981aef567cc661a4632e52555d7937">Eth_DispatchVirtmacUnsubscribeAllTraffic</a> (uint8 CtrlIdx)</td></tr>
<tr class="memdesc:ga1d981aef567cc661a4632e52555d7937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac all traffic unsubscription request to ethernet firmware.  <a href="#ga1d981aef567cc661a4632e52555d7937">More...</a><br /></td></tr>
<tr class="separator:ga1d981aef567cc661a4632e52555d7937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d1612ed495fc9f278ba97c7d1123da"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga98d1612ed495fc9f278ba97c7d1123da">Eth_DispatchVirtmacSubscribeDstMac</a> (uint8 CtrlIdx, uint8 *macAddress)</td></tr>
<tr class="memdesc:ga98d1612ed495fc9f278ba97c7d1123da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac destination mac traffic subscription request to ethernet firmware.  <a href="#ga98d1612ed495fc9f278ba97c7d1123da">More...</a><br /></td></tr>
<tr class="separator:ga98d1612ed495fc9f278ba97c7d1123da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10becd1a0c0135d82da9fb158860821b"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga10becd1a0c0135d82da9fb158860821b">Eth_DispatchVirtmacUnsubscribeDstMac</a> (uint8 CtrlIdx, uint8 *macAddress)</td></tr>
<tr class="memdesc:ga10becd1a0c0135d82da9fb158860821b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac destination traffic unsubscription request to ethernet firmware.  <a href="#ga10becd1a0c0135d82da9fb158860821b">More...</a><br /></td></tr>
<tr class="separator:ga10becd1a0c0135d82da9fb158860821b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga564a29068f1ae69b1ce78f61c43dc0ba"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga564a29068f1ae69b1ce78f61c43dc0ba">Eth_DispatchVirtmacAssociateIPv4Macaddr</a> (uint8 CtrlIdx, uint8 *ipv4Address, uint8 *macAddress)</td></tr>
<tr class="memdesc:ga564a29068f1ae69b1ce78f61c43dc0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac IPV4 address:destination mac association request to ethernet firmware.  <a href="#ga564a29068f1ae69b1ce78f61c43dc0ba">More...</a><br /></td></tr>
<tr class="separator:ga564a29068f1ae69b1ce78f61c43dc0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga859a393ce70911043218ba52be2ac056"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga859a393ce70911043218ba52be2ac056">Eth_DispatchVirtmacDisassociateIPv4Macaddr</a> (uint8 CtrlIdx, uint8 *ipv4Address)</td></tr>
<tr class="memdesc:ga859a393ce70911043218ba52be2ac056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac IPV4 address:destination mac disassociation request to ethernet firmware.  <a href="#ga859a393ce70911043218ba52be2ac056">More...</a><br /></td></tr>
<tr class="separator:ga859a393ce70911043218ba52be2ac056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a6d4a5213cf434b4640b6d16228169"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga19a6d4a5213cf434b4640b6d16228169">Eth_DispatchVirtmacAddUnicastAddr</a> (uint8 CtrlIdx, uint8 *macAddress, Eth_PortType port, uint32 vlanId)</td></tr>
<tr class="memdesc:ga19a6d4a5213cf434b4640b6d16228169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac addition of given unicast address to switch address resolution table request to ethernet firmware.  <a href="#ga19a6d4a5213cf434b4640b6d16228169">More...</a><br /></td></tr>
<tr class="separator:ga19a6d4a5213cf434b4640b6d16228169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382b72ebf466a6aeac3be3a103ce074e"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga382b72ebf466a6aeac3be3a103ce074e">Eth_DispatchVirtmacAddMcastAddr</a> (uint8 CtrlIdx, uint8 *macAddress, uint32 numLsbToIgnore, uint32 vlanId, Eth_PortListType *portList)</td></tr>
<tr class="memdesc:ga382b72ebf466a6aeac3be3a103ce074e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac addition of given multicast address to switch address resolution table request to ethernet firmware.  <a href="#ga382b72ebf466a6aeac3be3a103ce074e">More...</a><br /></td></tr>
<tr class="separator:ga382b72ebf466a6aeac3be3a103ce074e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b228ef4ab0b76e825e345c3206587ac"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga7b228ef4ab0b76e825e345c3206587ac">Eth_DispatchVirtmacDelAddr</a> (uint8 CtrlIdx, uint8 *macAddress, uint32 vlanId)</td></tr>
<tr class="separator:ga7b228ef4ab0b76e825e345c3206587ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb94dd36576b9d12babc5a266ac7958"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga5eb94dd36576b9d12babc5a266ac7958">Eth_DispatchVirtmacAddVlan</a> (uint8 CtrlIdx, uint32 vlanId, Eth_PortListType *portList)</td></tr>
<tr class="memdesc:ga5eb94dd36576b9d12babc5a266ac7958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch virtual mac addition of given vlan id to switch address resolution table request to ethernet firmware.  <a href="#ga5eb94dd36576b9d12babc5a266ac7958">More...</a><br /></td></tr>
<tr class="separator:ga5eb94dd36576b9d12babc5a266ac7958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5497419600153ccd4099b8ce6c1fa37d"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga5497419600153ccd4099b8ce6c1fa37d">Eth_DispatchVirtmacDelVlan</a> (uint8 CtrlIdx, uint32 vlanId)</td></tr>
<tr class="separator:ga5497419600153ccd4099b8ce6c1fa37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02d28635a9b76f5de124e7bb19e37b1e"><td class="memItemLeft" align="right" valign="top">Std_ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga02d28635a9b76f5de124e7bb19e37b1e">Eth_SendCustomNotify</a> (uint8 CtrlIdx, void *notifyInfo, uint32 notifyLen)</td></tr>
<tr class="separator:ga02d28635a9b76f5de124e7bb19e37b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Eth Driver Module SW Version Info</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf66f5f94cb0b8c1cea838698cd7c15b3"></a>Definitions for the Eth Driver version used for compatibility checks </p>
</td></tr>
<tr class="memitem:gaab7f53052188ea76999151b34f1deffa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gaab7f53052188ea76999151b34f1deffa">ETH_SW_MAJOR_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gaab7f53052188ea76999151b34f1deffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Implementation Major Version.  <a href="#gaab7f53052188ea76999151b34f1deffa">More...</a><br /></td></tr>
<tr class="separator:gaab7f53052188ea76999151b34f1deffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f674a0ede144b19f122d28e744a562"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga38f674a0ede144b19f122d28e744a562">ETH_SW_MINOR_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga38f674a0ede144b19f122d28e744a562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Implementation Minor Version.  <a href="#ga38f674a0ede144b19f122d28e744a562">More...</a><br /></td></tr>
<tr class="separator:ga38f674a0ede144b19f122d28e744a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119046d8d64662cfae1adc4a4d1f8228"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga119046d8d64662cfae1adc4a4d1f8228">ETH_SW_PATCH_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga119046d8d64662cfae1adc4a4d1f8228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Implementation Patch Version.  <a href="#ga119046d8d64662cfae1adc4a4d1f8228">More...</a><br /></td></tr>
<tr class="separator:ga119046d8d64662cfae1adc4a4d1f8228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Eth Driver Module AUTOSAR Version Info</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp30f781858652eaebc5fef9f8e6a0e901"></a>Definitions for the Etj Driver AUTOSAR version used for compatibility checks </p>
</td></tr>
<tr class="memitem:ga8f07fe106f2a485310764183bf002a42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga8f07fe106f2a485310764183bf002a42">ETH_AR_RELEASE_MAJOR_VERSION</a>&#160;&#160;&#160;(4U)</td></tr>
<tr class="memdesc:ga8f07fe106f2a485310764183bf002a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTOSAR Major version specification implemented by Eth Driver.  <a href="#ga8f07fe106f2a485310764183bf002a42">More...</a><br /></td></tr>
<tr class="separator:ga8f07fe106f2a485310764183bf002a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1be488f58689aa543fa28a97664476"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gade1be488f58689aa543fa28a97664476">ETH_AR_RELEASE_MINOR_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:gade1be488f58689aa543fa28a97664476"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTOSAR Minor version specification implemented by Eth Driver.  <a href="#gade1be488f58689aa543fa28a97664476">More...</a><br /></td></tr>
<tr class="separator:gade1be488f58689aa543fa28a97664476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8e9d72dc95c701f005c55539fc0380"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gaee8e9d72dc95c701f005c55539fc0380">ETH_AR_RELEASE_REVISION_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gaee8e9d72dc95c701f005c55539fc0380"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTOSAR Patch version specification implemented by Eth Driver.  <a href="#gaee8e9d72dc95c701f005c55539fc0380">More...</a><br /></td></tr>
<tr class="separator:gaee8e9d72dc95c701f005c55539fc0380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Eth Driver ID Info</h2></td></tr>
<tr class="memitem:ga26172126101ac180ebbc93d88ef47b8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga26172126101ac180ebbc93d88ef47b8c">ETH_VENDOR_ID</a>&#160;&#160;&#160;((uint16) 44U)</td></tr>
<tr class="memdesc:ga26172126101ac180ebbc93d88ef47b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texas Instruments Vendor ID.  <a href="#ga26172126101ac180ebbc93d88ef47b8c">More...</a><br /></td></tr>
<tr class="separator:ga26172126101ac180ebbc93d88ef47b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6e5593864cec80008d8cd6eae35a21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gafb6e5593864cec80008d8cd6eae35a21">ETH_MODULE_ID</a>&#160;&#160;&#160;((uint16) 88U)</td></tr>
<tr class="memdesc:gafb6e5593864cec80008d8cd6eae35a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eth Driver Module ID.  <a href="#gafb6e5593864cec80008d8cd6eae35a21">More...</a><br /></td></tr>
<tr class="separator:gafb6e5593864cec80008d8cd6eae35a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6290a706ac74b89bec7e790c66a24dae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga6290a706ac74b89bec7e790c66a24dae">ETH_INSTANCE_ID</a>&#160;&#160;&#160;((uint8) 0U)</td></tr>
<tr class="memdesc:ga6290a706ac74b89bec7e790c66a24dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eth Driver Instance ID.  <a href="#ga6290a706ac74b89bec7e790c66a24dae">More...</a><br /></td></tr>
<tr class="separator:ga6290a706ac74b89bec7e790c66a24dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Eth Controller names</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb8d5b4d2a6d9a4dee96f0064b1a8c953"></a>Symbolic names for the EthControllerId. </p>
</td></tr>
<tr class="memitem:gac07422d6164dc5f9b474399b6609ddae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gac07422d6164dc5f9b474399b6609ddae">ETH_CONTROLLER_ID_0</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gac07422d6164dc5f9b474399b6609ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eth controller ID 0.  <a href="#gac07422d6164dc5f9b474399b6609ddae">More...</a><br /></td></tr>
<tr class="separator:gac07422d6164dc5f9b474399b6609ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Eth Error Codes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1ddb76d90ee04c89222b39a00d197183"></a><a class="anchor" id="Eth_ErrorCodes"></a></p>
<p>Error codes returned by Eth functions </p>
</td></tr>
<tr class="memitem:ga08514e3331a76ef50cfd306d6e451894"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga08514e3331a76ef50cfd306d6e451894">ETH_E_INV_CTRL_IDX</a>&#160;&#160;&#160;((uint8) 0x01U)</td></tr>
<tr class="memdesc:ga08514e3331a76ef50cfd306d6e451894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid controller index.  <a href="#ga08514e3331a76ef50cfd306d6e451894">More...</a><br /></td></tr>
<tr class="separator:ga08514e3331a76ef50cfd306d6e451894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17b36d723e0e0e2c34fe6ea7cc1c924"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gab17b36d723e0e0e2c34fe6ea7cc1c924">ETH_E_NOT_INITIALIZED</a>&#160;&#160;&#160;((uint8) 0x02U)</td></tr>
<tr class="memdesc:gab17b36d723e0e0e2c34fe6ea7cc1c924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eth module or controller was not initialized.  <a href="#gab17b36d723e0e0e2c34fe6ea7cc1c924">More...</a><br /></td></tr>
<tr class="separator:gab17b36d723e0e0e2c34fe6ea7cc1c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb6efb0a03a4e0238b3d388e8ee332d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga1bb6efb0a03a4e0238b3d388e8ee332d">ETH_E_PARAM_POINTER</a>&#160;&#160;&#160;((uint8) 0x03U)</td></tr>
<tr class="memdesc:ga1bb6efb0a03a4e0238b3d388e8ee332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid pointer in parameter list.  <a href="#ga1bb6efb0a03a4e0238b3d388e8ee332d">More...</a><br /></td></tr>
<tr class="separator:ga1bb6efb0a03a4e0238b3d388e8ee332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad661110a8cae3b2ad6ea8e121bdc07e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gad661110a8cae3b2ad6ea8e121bdc07e6">ETH_E_INV_PARAM</a>&#160;&#160;&#160;((uint8) 0x04U)</td></tr>
<tr class="memdesc:gad661110a8cae3b2ad6ea8e121bdc07e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid parameter.  <a href="#gad661110a8cae3b2ad6ea8e121bdc07e6">More...</a><br /></td></tr>
<tr class="separator:gad661110a8cae3b2ad6ea8e121bdc07e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e107b5613da4cba7f819e9a83b383ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga8e107b5613da4cba7f819e9a83b383ad">ETH_E_INIT_FAILED</a>&#160;&#160;&#160;((uint8) 0x05U)</td></tr>
<tr class="memdesc:ga8e107b5613da4cba7f819e9a83b383ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization failure.  <a href="#ga8e107b5613da4cba7f819e9a83b383ad">More...</a><br /></td></tr>
<tr class="separator:ga8e107b5613da4cba7f819e9a83b383ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24bd3ec4d3ffde99898ebbe0fc6a1bec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga24bd3ec4d3ffde99898ebbe0fc6a1bec">ETH_E_INV_MODE</a>&#160;&#160;&#160;((uint8) 0x06U)</td></tr>
<tr class="memdesc:ga24bd3ec4d3ffde99898ebbe0fc6a1bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid mode.  <a href="#ga24bd3ec4d3ffde99898ebbe0fc6a1bec">More...</a><br /></td></tr>
<tr class="separator:ga24bd3ec4d3ffde99898ebbe0fc6a1bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3bcbceb27de50ca9d8d03e4a32d540a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#gac3bcbceb27de50ca9d8d03e4a32d540a">ETH_E_VIRTMAC_APIMISMATCH</a>&#160;&#160;&#160;((uint8) 0x07U)</td></tr>
<tr class="memdesc:gac3bcbceb27de50ca9d8d03e4a32d540a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mismatch in API version between Eth Driver and ethernet firmware.  <a href="#gac3bcbceb27de50ca9d8d03e4a32d540a">More...</a><br /></td></tr>
<tr class="separator:gac3bcbceb27de50ca9d8d03e4a32d540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358a63075c00d42b9476ca8ab62a6f00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga358a63075c00d42b9476ca8ab62a6f00">ETH_E_VIRTMAC_RPCCMDFAILED</a>&#160;&#160;&#160;((uint8) 0x08U)</td></tr>
<tr class="memdesc:ga358a63075c00d42b9476ca8ab62a6f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual MAC RPC command failed.  <a href="#ga358a63075c00d42b9476ca8ab62a6f00">More...</a><br /></td></tr>
<tr class="separator:ga358a63075c00d42b9476ca8ab62a6f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93774144555ee508578ec56fab75d260"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga93774144555ee508578ec56fab75d260">ETH_E_VIRTMAC_UNSUPPORTECLIENTNOTIFY</a>&#160;&#160;&#160;((uint8) 0x09U)</td></tr>
<tr class="memdesc:ga93774144555ee508578ec56fab75d260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ethernet MCAL RPC client received unhandled notify from ethernet firmware server.  <a href="#ga93774144555ee508578ec56fab75d260">More...</a><br /></td></tr>
<tr class="separator:ga93774144555ee508578ec56fab75d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583c0774917d6d17e46a55873a0d74e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCAL__ETH__API.html#ga583c0774917d6d17e46a55873a0d74e7">ETH_E_VIRTMAC_UNSUPPORTEDSRVCMD</a>&#160;&#160;&#160;((uint8) 0x0AU)</td></tr>
<tr class="memdesc:ga583c0774917d6d17e46a55873a0d74e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rpc Command sent by client not supported by server.  <a href="#ga583c0774917d6d17e46a55873a0d74e7">More...</a><br /></td></tr>
<tr class="separator:ga583c0774917d6d17e46a55873a0d74e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaab7f53052188ea76999151b34f1deffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab7f53052188ea76999151b34f1deffa">&#9670;&nbsp;</a></span>ETH_SW_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_SW_MAJOR_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver Implementation Major Version. </p>

</div>
</div>
<a id="ga38f674a0ede144b19f122d28e744a562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f674a0ede144b19f122d28e744a562">&#9670;&nbsp;</a></span>ETH_SW_MINOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_SW_MINOR_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver Implementation Minor Version. </p>

</div>
</div>
<a id="ga119046d8d64662cfae1adc4a4d1f8228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga119046d8d64662cfae1adc4a4d1f8228">&#9670;&nbsp;</a></span>ETH_SW_PATCH_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_SW_PATCH_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver Implementation Patch Version. </p>

</div>
</div>
<a id="ga8f07fe106f2a485310764183bf002a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f07fe106f2a485310764183bf002a42">&#9670;&nbsp;</a></span>ETH_AR_RELEASE_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_AR_RELEASE_MAJOR_VERSION&#160;&#160;&#160;(4U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTOSAR Major version specification implemented by Eth Driver. </p>

</div>
</div>
<a id="gade1be488f58689aa543fa28a97664476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1be488f58689aa543fa28a97664476">&#9670;&nbsp;</a></span>ETH_AR_RELEASE_MINOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_AR_RELEASE_MINOR_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTOSAR Minor version specification implemented by Eth Driver. </p>

</div>
</div>
<a id="gaee8e9d72dc95c701f005c55539fc0380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8e9d72dc95c701f005c55539fc0380">&#9670;&nbsp;</a></span>ETH_AR_RELEASE_REVISION_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_AR_RELEASE_REVISION_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTOSAR Patch version specification implemented by Eth Driver. </p>

</div>
</div>
<a id="ga26172126101ac180ebbc93d88ef47b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26172126101ac180ebbc93d88ef47b8c">&#9670;&nbsp;</a></span>ETH_VENDOR_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VENDOR_ID&#160;&#160;&#160;((uint16) 44U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Texas Instruments Vendor ID. </p>

</div>
</div>
<a id="gafb6e5593864cec80008d8cd6eae35a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb6e5593864cec80008d8cd6eae35a21">&#9670;&nbsp;</a></span>ETH_MODULE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_MODULE_ID&#160;&#160;&#160;((uint16) 88U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eth Driver Module ID. </p>

</div>
</div>
<a id="ga6290a706ac74b89bec7e790c66a24dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6290a706ac74b89bec7e790c66a24dae">&#9670;&nbsp;</a></span>ETH_INSTANCE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_INSTANCE_ID&#160;&#160;&#160;((uint8) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eth Driver Instance ID. </p>

</div>
</div>
<a id="gac07422d6164dc5f9b474399b6609ddae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac07422d6164dc5f9b474399b6609ddae">&#9670;&nbsp;</a></span>ETH_CONTROLLER_ID_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_CONTROLLER_ID_0&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eth controller ID 0. </p>

</div>
</div>
<a id="ga08514e3331a76ef50cfd306d6e451894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08514e3331a76ef50cfd306d6e451894">&#9670;&nbsp;</a></span>ETH_E_INV_CTRL_IDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_INV_CTRL_IDX&#160;&#160;&#160;((uint8) 0x01U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid controller index. </p>

</div>
</div>
<a id="gab17b36d723e0e0e2c34fe6ea7cc1c924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab17b36d723e0e0e2c34fe6ea7cc1c924">&#9670;&nbsp;</a></span>ETH_E_NOT_INITIALIZED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_NOT_INITIALIZED&#160;&#160;&#160;((uint8) 0x02U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eth module or controller was not initialized. </p>

</div>
</div>
<a id="ga1bb6efb0a03a4e0238b3d388e8ee332d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bb6efb0a03a4e0238b3d388e8ee332d">&#9670;&nbsp;</a></span>ETH_E_PARAM_POINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_PARAM_POINTER&#160;&#160;&#160;((uint8) 0x03U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid pointer in parameter list. </p>

</div>
</div>
<a id="gad661110a8cae3b2ad6ea8e121bdc07e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad661110a8cae3b2ad6ea8e121bdc07e6">&#9670;&nbsp;</a></span>ETH_E_INV_PARAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_INV_PARAM&#160;&#160;&#160;((uint8) 0x04U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid parameter. </p>

</div>
</div>
<a id="ga8e107b5613da4cba7f819e9a83b383ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e107b5613da4cba7f819e9a83b383ad">&#9670;&nbsp;</a></span>ETH_E_INIT_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_INIT_FAILED&#160;&#160;&#160;((uint8) 0x05U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization failure. </p>

</div>
</div>
<a id="ga24bd3ec4d3ffde99898ebbe0fc6a1bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24bd3ec4d3ffde99898ebbe0fc6a1bec">&#9670;&nbsp;</a></span>ETH_E_INV_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_INV_MODE&#160;&#160;&#160;((uint8) 0x06U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid mode. </p>

</div>
</div>
<a id="gac3bcbceb27de50ca9d8d03e4a32d540a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3bcbceb27de50ca9d8d03e4a32d540a">&#9670;&nbsp;</a></span>ETH_E_VIRTMAC_APIMISMATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_VIRTMAC_APIMISMATCH&#160;&#160;&#160;((uint8) 0x07U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mismatch in API version between Eth Driver and ethernet firmware. </p>

</div>
</div>
<a id="ga358a63075c00d42b9476ca8ab62a6f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga358a63075c00d42b9476ca8ab62a6f00">&#9670;&nbsp;</a></span>ETH_E_VIRTMAC_RPCCMDFAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_VIRTMAC_RPCCMDFAILED&#160;&#160;&#160;((uint8) 0x08U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual MAC RPC command failed. </p>

</div>
</div>
<a id="ga93774144555ee508578ec56fab75d260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93774144555ee508578ec56fab75d260">&#9670;&nbsp;</a></span>ETH_E_VIRTMAC_UNSUPPORTECLIENTNOTIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_VIRTMAC_UNSUPPORTECLIENTNOTIFY&#160;&#160;&#160;((uint8) 0x09U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ethernet MCAL RPC client received unhandled notify from ethernet firmware server. </p>

</div>
</div>
<a id="ga583c0774917d6d17e46a55873a0d74e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga583c0774917d6d17e46a55873a0d74e7">&#9670;&nbsp;</a></span>ETH_E_VIRTMAC_UNSUPPORTEDSRVCMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_E_VIRTMAC_UNSUPPORTEDSRVCMD&#160;&#160;&#160;((uint8) 0x0AU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rpc Command sent by client not supported by server. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5d7a2ab7987412f33d9f36f24216a656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d7a2ab7987412f33d9f36f24216a656">&#9670;&nbsp;</a></span>Eth_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_Init </td>
          <td>(</td>
          <td class="paramtype">const Eth_ConfigType *&#160;</td>
          <td class="paramname"><em>CfgPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the driver. </p>
<pre class="fragment">*  Service name      : Eth_Init
*  Syntax            : void Eth_Init(
*                          const Eth_ConfigType* CfgPtr
*                      )
*  Service ID[hex]   : 0x01
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CfPtr. Points to the implementation specific structure
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Initializes the Ethernet Driver.
*  </pre> 
</div>
</div>
<a id="ga6ad3ee03f3ca94dca5190fe13fb7513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ad3ee03f3ca94dca5190fe13fb7513d">&#9670;&nbsp;</a></span>Eth_ControllerInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_ControllerInit </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CfgIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the indexed controller. </p>
<pre class="fragment">*  Service name      : Eth_ControllerInit
*  Syntax            : Std_ReturnType Eth_ControllerInit(
*                          uint8 CtrlIdx,
*                          uint8 CfgIdx
*                      )
*  Service ID[hex]   : 0x02
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      CfgIdx. Index of the used configuration
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transceiver could not be initialized
*  Description       : Initializes the indexed controller.
*  </pre> 
</div>
</div>
<a id="ga07088f1594c14ef1d9b5ad0a52bad477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07088f1594c14ef1d9b5ad0a52bad477">&#9670;&nbsp;</a></span>Eth_SetControllerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_SetControllerMode </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_ModeType&#160;</td>
          <td class="paramname"><em>CtrlMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables / disables the indexed controller. </p>
<pre class="fragment">*  Service name      : Eth_SetControllerMode
*  Syntax            : Std_ReturnType Eth_SetControllerMode(
*                          uint8 CtrlIdx,
*                          Eth_ModeType CtrlMode
*                      )
*  Service ID[hex]   : 0x03
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      CtrlMode.
*                        ETH_MODE_DOWN: disable the controller
*                        ETH_MODE_ACTIVE: enable the controller
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: controller mode could not be changed
*  Description       : Enables / disables the indexed controller.
*  </pre> 
</div>
</div>
<a id="ga9eff360823a9ae54087b9276f59befe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eff360823a9ae54087b9276f59befe5">&#9670;&nbsp;</a></span>Eth_GetControllerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_GetControllerMode </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_ModeType *&#160;</td>
          <td class="paramname"><em>CtrlModePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the state of the indexed controller. </p>
<pre class="fragment">*  Service name      : Eth_SetControllerMode
*  Syntax            : Std_ReturnType Eth_GetControllerMode(
*                          uint8 CtrlIdx,
*                          Eth_ModeType *CtrlModePtr
*                      )
*  Service ID[hex]   : 0x04
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): CtrlModePtr
*                        ETH_MODE_DOWN: the controller is disabled
*                        ETH_MODE_ACTIVE: the controller is enabled
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: controller mode could not be obtained
*  Description       : Obtains the state of the indexed controller.
*  </pre> 
</div>
</div>
<a id="gaafc915c5b06fd70c6c90d6fe16d22b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafc915c5b06fd70c6c90d6fe16d22b05">&#9670;&nbsp;</a></span>Eth_GetPhysAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_GetPhysAddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>PhysAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function obtains the physical source address used by the indexed controller. </p>
<pre class="fragment">*  Service name      : Eth_GetPhysAddr
*  Syntax            : void Eth_GetPhysAddr(
*                          uint8 CtrlIdx,
*                          uint8 *PhysAddrPtr
*                      )
*  Service ID[hex]   : 0x08
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout):
*  Parameters (out)  : PhysAddrPtr. Physical source address (MAC address) in network
*                                   byte order
*  Return value      : None
*  Description       : Obtains the physical source address used by the indexed
*                      controller.
*  </pre> 
</div>
</div>
<a id="ga3c1912a1d30eba82b7ce6914ceb0b016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c1912a1d30eba82b7ce6914ceb0b016">&#9670;&nbsp;</a></span>Eth_SetPhysAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_SetPhysAddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>PhysAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the physical source address used by the indexed controller. </p>
<pre class="fragment">*  Service name      : Eth_GetPhysAddr
*  Syntax            : void Eth_SetPhysAddr(
*                          uint8 CtrlIdx,
*                          const uint8* PhysAddrPtr
*                      )
*  Service ID[hex]   : 0x13
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant for the same CtrlIdx, reentrant for different
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      PhysAddrPtr. Pointer to memory containing the physical source
*                                   address (MAC address) in network byte order
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Sets the physical source address used by the indexed
*                      controller.
*  </pre> 
</div>
</div>
<a id="ga6b628ac4bd732ae11172ea9eb3b46747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b628ac4bd732ae11172ea9eb3b46747">&#9670;&nbsp;</a></span>Eth_UpdatePhysAddrFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_UpdatePhysAddrFilter </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>PhysAddrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_FilterActionType&#160;</td>
          <td class="paramname"><em>Action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the physical source address to / from the indexed controller filter. </p>
<pre class="fragment">*  Service name      : Eth_UpdatePhysAddrFilter
*  Syntax            : Std_ReturnType Eth_UpdatePhysAddrFilter(
*                          uint8 CtrlIdx,
*                          uint8* PhysAddrPtr,
*                          Eth_FilterActionType Action
*                      )
*  Service ID[hex]   : 0x12
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant for the same CtrlIdx, reentrant for different
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      PhysAddrPtr. Pointer to memory containing the physical source
*                                   address (MAC address) in network byte order
*                      Action. Add or remove the address from the Ethernet controllers
*                              filter
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: filter was successfully changed
*                        E_NOT_OK: filter could not be changed
*  Description       : Updates the physical source address to/from the indexed ontroller
*                      filter. If the Ethernet Controller is not capable to do the
*                      filtering, the software has to do this.
*  </pre> 
</div>
</div>
<a id="gad1e74f407c48ef5e1a80b9d1fb33b192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e74f407c48ef5e1a80b9d1fb33b192">&#9670;&nbsp;</a></span>Eth_WriteMii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_WriteMii </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>TrcvIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>RegIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>RegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures a transceiver register or triggers a function offered by the receiver Service. </p>
<pre class="fragment">*  Service name      : Eth_WriteMii
*  Syntax            : Std_ReturnType Eth_WriteMii(
*                          uint8 CtrlIdx,
*                          uint8 TrcvIdx,
*                          uint8 RegIdx,
*                          uint16 RegVal
*                      )
*  Service ID[hex]   : 0x05
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      TrcvIdx. Index of the transceiver on the MII
*                      RegIdx.Index of the transceiver register on the MII
*                      RegVal. Value to be written into the indexed registerNone
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: Service accepted
*                        E_NOT_OK: Service denied
*                        ETH_E_NO_ACCESS: Ethernet transceiver access failure
*  Description       : Configures a transceiver register or triggers a function
*                      offered by the receiver.
*  </pre> 
</div>
</div>
<a id="gab0a27206034ea65456d8ad4cbf5d4b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a27206034ea65456d8ad4cbf5d4b19">&#9670;&nbsp;</a></span>Eth_ReadMii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_ReadMii </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>TrcvIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>RegIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>RegValPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a transceiver register. </p>
<pre class="fragment">*  Service name      : Eth_ReadMii
*  Syntax            : Std_ReturnType Eth_ReadMii(
*                          uint8 CtrlIdx,
*                          uint8 TrcvIdx,
*                          uint8 RegIdx,
*                          uint16* RegValPtr
*                      )
*  Service ID[hex]   : 0x06
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      TrcvIdx. Index of the transceiver on the MII
*                      RegIdx. Index of the transceiver register on the MII
*                      RegVal. Value to be written into the indexed register
*  Parameters (inout): None
*  Parameters (out)  : RegValPtr. Filled with the register content of the indexed
*                                 register
*  Return value      : Std_ReturnType
*                        E_OK: Service accepted
*                        E_NOT_OK: Service denied
*                        ETH_E_NO_ACCESS: Ethernet transceiver access failure
*  Description       : Reads a transceiver register.
*  </pre> 
</div>
</div>
<a id="ga20283f2c687eb8dcfddcc3e1ac6da1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20283f2c687eb8dcfddcc3e1ac6da1db">&#9670;&nbsp;</a></span>Eth_GetDropCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_GetDropCount </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CountValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>DropCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a list with drop counter values of the corresponding controller. </p>
<pre class="fragment">*  Service name      : Eth_GetDropCount
*  Syntax            : Std_ReturnType Eth_GetDropCount(
*                          uint8 CtrlIdx,
*                          uint8 CountValues,
*                          uint32* DropCount
*                      )
*  Service ID[hex]   : 0x14
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): CountValues
*                        In: Maximal number of values which can be written from
*                            DropCount
*                        Out: Number of values which are returned in the
*                             DropCount list
*  Parameters (out)  : DropCount. The interpretation of this list of values is
*                                 hardware dependent
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: drop counter could not be obtained
*  Description       : Reads a list with drop counter values of the corresponding
*                      controller. The meaning of these values is hardware dependent.
*                      However, the list DropCount[] shall contain the following
*                      values in the given order, where the maximal possible value
*                      shall denote an invalid value, e.g. if this counter is not
*                      available:
*                       1.) dropped packets due to buffer overrun
*                       2.) dropped packets due to CRC errors
*                       3.) number of undersize packets which were less than 64
*                           octets long (excluding framing bits, but including FCS
*                           octets) and were otherwise will formed
*                        4.) number of oversize packets which are longer than 1518
*                           octets (excluding framing bits, but including FCS octets)
*                           and were otherwise well formed. (see IETF RFC 1757)
*                       5.) number of alignment errors, i.e. packets which are
*                           received and are not an integral number of octets in length
*                           and do not pass the CRC
*                       6.) SQE test error according to IETF RFC1643
*                           dot3StatsSQETestErrors
*                       7.) The number of inbound packets which were chosen to be
*                           discarded even though no errors had been detected to
*                           prevent their being deliverable to a higherlayer protocol.
*                           One possible reason for discarding such a packet could be
*                           to free up buffer space. (see IETF RFC 2233 ifInDiscards)
*                       8.) total number of erroneous inbound packets
*                       9.) The number of outbound packets which were chosen to
*                           be discarded even though no errors had been detected to
*                           prevent their being transmitted. One possible reason for
*                           discarding such a packet could be to free up buffer space.
*                           (see IETF RFC 2233 ifOutDiscards)
*                      10.) total number of erroneous outbound packets
*                      11.) Single collision frames: A count of successfully transmitted
*                           frames on a particular interface for which transmission is
*                           inhibited by exactly one collision. (see IETF RFC1643
*                           dot3StatsSingleCollisionFrames)
*                      12.) Multiple collision frames: A count of successfully
*                           transmitted frames on a particular interface for which
*                           transmission is inhibited by more than one collision.
*                           (see IETF RFC1643 dot3StatsMultipleCollisionFrames)
*                      13.) Number of deferred transmission: A count of frames
*                           for which the first transmission attempt on a particular
*                           interface is delayed because the medium is busy.
*                           (see IETF RFC1643 dot3StatsDeferredTransmissions)
*                      14.) Number of late collisions: The number of times that a
*                           collision is detected on a particular interface later than
*                           512 bit-times into the transmission of a packet
*                           (see IETF RFC1643 dot3StatsLateCollisions)
*                      15.) the following positions in the list can contain hardware
*                           dependent counter values
*  </pre> 
</div>
</div>
<a id="ga94a8c0e8c5fa8b44fade2183959e629f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a8c0e8c5fa8b44fade2183959e629f">&#9670;&nbsp;</a></span>Eth_GetEtherStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_GetEtherStats </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>etherStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a list with statistics values of the corresponding controller. </p>
<pre class="fragment">*  Service name      : Eth_GetEtherStats
*  Syntax            : Std_ReturnType Eth_GetEtherStats(
*                          uint8 CtrlIdx,
*                          uint32* etherStats
*                      )
*  Service ID[hex]   : 0x15
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : etherStats. List of values according to IETF RFC 2819
*                                  (Remote Network Monitoring Management Information
*                                  Base)
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: drop counter could not be obtained
*  Description       : Returns the following list according to IETF RFC2819,
*                      where the maximal possible value shall denote an invalid value,
*                      e.g. if this counter is not available:
*                       1. etherStatsDropEvents
*                       2. etherStatsOctets
*                       3. etherStatsPkts
*                       4. etherStatsBroadcastPkts
*                       5. etherStatsMulticastPkts
*                       6. etherStatsCrcAlignErrors
*                       7. etherStatsUndersizePkts
*                       8. etherStatsOversizePkts
*                       9. etherStatsFragments
*                      10. etherStatsJabbers
*                      11. etherStatsCollisions
*                      12. etherStatsPkts64Octets
*                      13. etherStatsPkts65to127Octets
*                      14. etherStatsPkts128to255Octets
*                      15. etherStatsPkts256to511Octets
*                      16. etherStatsPkts512to1023Octets
*                      17. etherStatsPkts1024to1518Octets
*  </pre> 
</div>
</div>
<a id="ga8dcb0a770ebf39f85a98d650b2c54284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dcb0a770ebf39f85a98d650b2c54284">&#9670;&nbsp;</a></span>Eth_GetCurrentTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_GetCurrentTime </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampQualType *&#160;</td>
          <td class="paramname"><em>timeQualPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampType *&#160;</td>
          <td class="paramname"><em>timeStampPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a time value out of the HW registers. </p>
<pre class="fragment">*  Service name      : Eth_GetCurrentTime
*  Syntax            : Std_ReturnType Eth_GetCurrentTime(
*                          uint8 CtrlIdx,
*                          Eth_TimeStampQualType *timeQualPtr,
*                          Eth_TimeStampType *timeStampPtr
*                      )
*  Service ID[hex]   : 0x16
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : timeQualPtr. Quality of HW time stamp, e.g. based on current
*                                   drift
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: failed
*  Description       : Returns a time value out of the HW registers according
*                      to the capability of the HW. Is the HW resolution is lower than
*                      the Eth_TimeStampType resolution resp. range, than an the
*                      remaining bits will be filled with 0.
*  </pre> 
</div>
</div>
<a id="ga79cf00bdd342e92f173f8599e8b1453f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79cf00bdd342e92f173f8599e8b1453f">&#9670;&nbsp;</a></span>Eth_EnableEgressTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_EnableEgressTimeStamp </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>BufIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function activates egress time stamping on a dedicated message object. </p>
<pre class="fragment">*  Service name      : Eth_EnableEgressTimeStamp
*  Syntax            : void Eth_EnableEgressTimeStamp(
*                          uint8 CtrlIdx,
*                          uint8 BufIdx
*                      )
*  Service ID[hex]   : 0x17
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      BufIdx. Index of the message buffer, where Application
*                              expects egress time stamping
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Activates egress time stamping on a dedicated message
*                      object.
*                      Some HW does store once the egress time stamp marker and
*                      some HW needs it always before transmission. There will be
*                      no disable functionality, due to the fact, that the message
*                      type is always "time stamped" by network design.
*  </pre> 
</div>
</div>
<a id="ga55ff2195591d889199664c70aba6fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ff2195591d889199664c70aba6fd76">&#9670;&nbsp;</a></span>Eth_GetEgressTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_GetEgressTimeStamp </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>BufIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampQualType *&#160;</td>
          <td class="paramname"><em>timeQualPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampType *&#160;</td>
          <td class="paramname"><em>timeStampPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads back the egress time stamp on a dedicated message object. </p>
<pre class="fragment">*  Service name      : Eth_GetEgressTimeStamp
*  Syntax            : void Eth_GetEgressTimeStamp(
*                          uint8 CtrlIdx,
*                          uint8 BufIdx,
*                          Eth_TimeStampQualType* timeQualPtr,
*                          Eth_TimeStampType *timeStampPtr
*                          )
*  Service ID[hex]   : 0x18
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      BufIdx. Index of the message buffer, where Application
*                              expects egress time stamping
*  Parameters (inout): timeQualPtr. Quality of HW time stamp, e.g. based on current
*                                   drift
*                      timeStampPtr. Current time stamp
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Reads back the egress time stamp on a dedicated message
*                      object.
*                      It must be called within the TxConfirmation() function.
*  </pre> 
</div>
</div>
<a id="ga399e79b1dffaa1e84695d49dc3aeb10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399e79b1dffaa1e84695d49dc3aeb10e">&#9670;&nbsp;</a></span>Eth_GetIngressTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_GetIngressTimeStamp </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_DataType *&#160;</td>
          <td class="paramname"><em>DataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampQualType *&#160;</td>
          <td class="paramname"><em>timeQualPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampType *&#160;</td>
          <td class="paramname"><em>timeStampPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads back the ingress time stamp on a dedicated message object. </p>
<pre class="fragment">*  Service name      : Eth_GetIngressTimeStamp
*  Syntax            : void Eth_GetIngressTimeStamp(
*                          uint8 CtrlIdx,
*                          Eth_DataType* DataPtr,
*                          Eth_TimeStampQualType* timeQualPtr,
*                          Eth_TimeStampType *timeStampPtr
*                      )
*  Service ID[hex]   : 0x19
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      DataPtr. Pointer to the message buffer, where Application
*                               expects ingress time stamping
*  Parameters (inout): timeQualPtr. Quality of HW time stamp, e.g. based on current
*                                   drift
*                      timeStampPtr. Current time stamp
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Reads back the ingress time stamp on a dedicated message
*                      object.
*                      It must be called within the RxIndication() function.
*  </pre> 
</div>
</div>
<a id="ga4554c1750edbc367785498ccf1e4cf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4554c1750edbc367785498ccf1e4cf32">&#9670;&nbsp;</a></span>Eth_SetCorrectionTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_SetCorrectionTime </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeIntDiffType *&#160;</td>
          <td class="paramname"><em>timeOffsetPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_RateRatioType *&#160;</td>
          <td class="paramname"><em>rateRatioPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the Time Slave to adjust the local ETH Reference clock in HW. </p>
<pre class="fragment">*  Service name      : Eth_SetCorrectionTime
*  Syntax            : void Eth_SetCorrectionTime(
*                          uint8 CtrlIdx,
*                          Eth_TimeIntDiffType* timeOffsetPtr,
*                          Eth_RateRatioType *rateRatioPtr
*                      )
*  Service ID[hex]   : 0x1A
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): timeOffsetPtr. Offset between time stamp grandmaster and
*                                    time stamp by local clock:
*                        (OriginTimeStampSync[FUP] - IngressTimeStampSync) +
*                         Pdelay
*                      rateRatioPtr. Time elements to calculate and to modify the
*                                    ratio of the frequency of the grandmaster in
*                                    relation to the frequency of the Local Clock
*                                    with:
*                        ratio = OriginTimeStampDelta / IngressTimeStampDelta
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Allows the Time Slave to adjust the local ETH Reference
*                      clock in HW.
*  </pre> 
</div>
</div>
<a id="ga1237ff1adbac0e4e3fc343ee8fd5ab70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1237ff1adbac0e4e3fc343ee8fd5ab70">&#9670;&nbsp;</a></span>Eth_SetGlobalTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_SetGlobalTime </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_TimeStampType *&#160;</td>
          <td class="paramname"><em>timeStampPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the Time Master to adjust the global ETH Reference clock in HW. </p>
<pre class="fragment">*  Service name      : Eth_SetGlobalTime
*  Syntax            : Std_ReturnType Eth_SetGlobalTime(
*                          uint8 CtrlIdx,
*                          Eth_TimeStampType* timeStampPtr
*                      )
*  Service ID[hex]   : 0x1B
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      timeStampPtr. New time stamp
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: failed
*  Description       : Allows the Time Master to adjust the global ETH Reference
*                      clock in HW. We can use this method to set a global time base
*                      on ETH in general or to synchronize the global ETH time base
*                      with another time base, e.g. FlexRay.
*  </pre> 
</div>
</div>
<a id="ga334c1e16b3010fb7bd65c0197bf91c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga334c1e16b3010fb7bd65c0197bf91c1f">&#9670;&nbsp;</a></span>Eth_ProvideTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufReq_ReturnType Eth_ProvideTxBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_BufIdxType *&#160;</td>
          <td class="paramname"><em>BufIdxPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 **&#160;</td>
          <td class="paramname"><em>BufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>LenBytePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides access to a transmit buffer of the specified controller. </p>
<pre class="fragment">*  Service name      : Eth_ProvideTxBuffer
*  Syntax            : BufReq_ReturnType Eth_ProvideTxBuffer(
*                          uint8 CtrlIdx,
*                          uint8* BufIdxPtr,
*                          uint8** BufPtr,
*                          uint16* LenBytePtr
*                      )
*  Service ID[hex]   : 0x09
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): LenBytePtr
*                        In: desired length in bytes, out: granted length in bytes
*  Parameters (out)  : BufIdxPtr. Index to the granted buffer resource. To be used
*                                 for subsequent requests
*                      BufPtr. Pointer to the granted buffer
*  Return value      : BufReq_ReturnType
*                        BUFREQ_OK: success
*                        BUFREQ_E_NOT_OK: development error detected
*                        BUFREQ_E_BUSY: all buffers in use
*                        BUFREQ_E_OVFL: requested buffer too large
*  Description       : Provides access to a transmit buffer of the specified
*                      controller.
*  </pre> 
</div>
</div>
<a id="ga770639a1e024f8d2b10b0789dc4f0a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770639a1e024f8d2b10b0789dc4f0a8c">&#9670;&nbsp;</a></span>Eth_Transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_Transmit </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_BufIdxType&#160;</td>
          <td class="paramname"><em>BufIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_FrameType&#160;</td>
          <td class="paramname"><em>FrameType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>TxConfirmation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>LenByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>PhysAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function triggers transmission of a previously filled transmit buffer. </p>
<pre class="fragment">*  Service name      : Eth_Transmit
*  Syntax            : Std_ReturnType Eth_Transmit(
*                          uint8 CtrlIdx,
*                          uint8 BufIdx,
*                          Eth_FrameType FrameType,
*                          boolean TxConfirmation,
*                          uint16 LenByte,
*                          uint8 *PhysAddrPtr)
*  Service ID[hex]   : 0xA
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*                      BufIdx. Index of the buffer resource
*                      FrameType. Ethernet frame type
*                      TxConfirmation. Activates transmission confirmation
*                      LenByte. Data length in byte
*                      PhysAddrPtr. Physical target address (MAC address) in
*                                   network byte order
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*  Description       : Triggers transmission of a previously filled transmit
*                      buffer.
*  </pre> 
</div>
</div>
<a id="gad30f3fd7b78c5b59a4a8d25b713af82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad30f3fd7b78c5b59a4a8d25b713af82f">&#9670;&nbsp;</a></span>Eth_Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_Receive </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_RxStatusType *&#160;</td>
          <td class="paramname"><em>RxStatusPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function triggers frame reception. </p>
<pre class="fragment">*  Service name      : Eth_Receive
*  Syntax            : void Eth_Receive(
*                          uint8 CtrlIdx,
*                          Eth_RxStatusType* RxStatusPtr
*                      )
*  Service ID[hex]   : 0xB
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                               Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : RxStatusPtr. Indicates whether a frame has been received and
*                                   if so, whether more frames are available or
*                                   frames got lost
*  Return value      : None
*  Description       : Triggers frame reception.
*  </pre> 
</div>
</div>
<a id="gafc8c58041c5362473af2f3799c046710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc8c58041c5362473af2f3799c046710">&#9670;&nbsp;</a></span>Eth_TxConfirmation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_TxConfirmation </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function triggers frame transmission confirmation. </p>
<pre class="fragment">*  Service name      : Eth_TxConfirmation
*  Syntax            : void Eth_TxConfirmation(
*                          uint8 CtrlIdx
*                      )
*  Service ID[hex]   : 0xC
*  Sync/Async        : Synchronous
*  Reentrancy        : Non Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      : None
*  Description       : Triggers frame transmission confirmation.
*  </pre> 
</div>
</div>
<a id="ga9d6f59fd237df42d1f5ee35fe4cea29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6f59fd237df42d1f5ee35fe4cea29f">&#9670;&nbsp;</a></span>Eth_GetVersionInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_GetVersionInfo </td>
          <td>(</td>
          <td class="paramtype">Std_VersionInfoType *&#160;</td>
          <td class="paramname"><em>VersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returns the version information of this module. </p>
<pre class="fragment">*  Service name      : Eth_GetVersionInfo
*  Syntax            : void Eth_GetVersionInfo(
*                          Std_VersionInfoType* versioninfo
*                      )
*  Service ID[hex]   : 0xD
*  Sync/Async        : Synchronous
*  Reentrancy        : Reentrant
*  Parameters (in)   : None
*  Parameters (inout): None
*  Parameters (out)  : VersionInfoPtr. Pointer to where to store the version
*                      information of this module
*  Return value      : None
*  Description       : Returns the version information of this module.
*  </pre> 
</div>
</div>
<a id="gacb4bf643bb9beec0e0eeb47d967e9af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb4bf643bb9beec0e0eeb47d967e9af5">&#9670;&nbsp;</a></span>Eth_MainFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eth_MainFunction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function checks for controller errors and lost frames. Used for polling state changes. Calls EthIf_CtrlModeIndication when the controller mode changed. </p>
<pre class="fragment">*  Service name      : Eth_MainFunction
*  Syntax            : void Eth_MainFunction(
*                          void
*                      )
*  Service ID[hex]   : 0x0A
*  Description       : The function checks for controller errors and lost frames.
*                      Used for polling state changes. Calls EthIf_CtrlModeIndication
*                      when the controller mode changed.
*  </pre> 
</div>
</div>
<a id="gab7fe65a654aca3d95e102cef647e39aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7fe65a654aca3d95e102cef647e39aa">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacInit </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac initialization request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacInit
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacInit(CtrlIdx)
*  Service ID[hex]   : 0x1CU
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to allocate data path resources. 
*                       The allocated Tx, Rx DMA channels are then setup in the 
*                       Eth_ControllerInit() API. The function only send the 
*                       RPC msg to ethernet firmware core. Completion of RPC msg 
*                       processing is indicated by invokcation of 
*                       rpcCmdComplete part of Eth_ConfigType sturcture.
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="gad8ecedc4d3977b62368b624aa68dc591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8ecedc4d3977b62368b624aa68dc591">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacDeinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacDeinit </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac deinit request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacDeinit
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacDeinit(CtrlIdx)
*  Service ID[hex]   : 0x1DU
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to free data path resources. 
*                       This function dispatches RPC msg to ethernet firmware core. 
*                       Completion of RPC msg processing is indicated by invokcation
*                       of rpcCmdComplete part of Eth_ConfigType sturcture.
*                       Once complete the data path to Ethernet virtual MAC
*                       has been torn down and driver can no loner send or receive packets
*  </pre> 
</div>
</div>
<a id="gafa5e44bc25472b2e6bf18890565f3801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5e44bc25472b2e6bf18890565f3801">&#9670;&nbsp;</a></span>Eth_NotifyVirtmacMsgReceived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_NotifyVirtmacMsgReceived </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify Ethernet driver that a RPC msg has been received from ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_NotifyVirtmacMsgReceived
*  Syntax            : Std_ReturnType Eth_NotifyVirtmacMsgReceived(CtrlIdx)
*  Service ID[hex]   : 0x1EU
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  Invocation of this function will cause the Ethernet 
*                       MCAL driver to process any queued messages received
*                       from ethernet firmware. Depending on type of msg received
*                       ethernet firmware will invoke rpcCmdComplete/fwRegisteredCb
*                       application callbacks. This function is typically
*                       called from the Cdd_IpcNewMessageNotify if the channel
*                       id matches the Ethernet MCAL IPC channel id
*                       (ethfwRpcComChId member of Eth_ConfigType structure)
*                       Application can also trigger recv msg processing by
*                       setting pollRecvMsgInEthMain in Eth_ConfigType to true
*                       Invoking Eth_MainFunction with this config set will
*                       trigger recv msg processing. In triggering recv msg
*                       processing from Eth_MainFunction, this API should be
*                       disabled
*                       
*  </pre> 
</div>
</div>
<a id="ga21d5aa2dfeaa6eeceefaf7001070f336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d5aa2dfeaa6eeceefaf7001070f336">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacSubscribeAllTraffic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacSubscribeAllTraffic </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac all traffic subscription request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacSubscribeAllTraffic
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacSubscribeAllTraffic(CtrlIdx)
*  Service ID[hex]   : 0x1FU
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to subscribe to all default flow traffic 
*                       received on host port.The default flow contains all
*                       traffic that is not explicitly categorized into a specific 
*                       flow using a classifier entry in the switch .
*                       Note that only one core can subscribe to default flow
*                       traffic in a system and this is by default the ethernet
*                       firmware core. This API requires a compatible ethernet
*                       firmware that _does_ _not_ subscribe to default flow
*                       and allows Eth Driver to subscribe to default flow
*                       The function only send the RPC msg to ethernet firmware core. 
*                       Completion of RPC msg processing is indicated by invokcation of 
*                       rpcCmdComplete part of Eth_ConfigType sturcture.
*                       A failure status indicates ethernet firmware does not allow
*                       AUTOSAR Eth Driver to subscribe to default flow
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeAllTraffic()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga1d981aef567cc661a4632e52555d7937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d981aef567cc661a4632e52555d7937">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacUnsubscribeAllTraffic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacUnsubscribeAllTraffic </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac all traffic unsubscription request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacUnsubscribeAllTraffic
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacUnsubscribeAllTraffic(CtrlIdx)
*  Service ID[hex]   : 0x20U
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to unsubscribe to all default flow traffic 
*                       received on host port.The driver should have subscribed 
*                       to all default flow traffic previously by invoking 
*                       Eth_DispatchVirtmacSubscribeAllTraffic().
*                       On unsubscribing to default flow all traffic with
*                       default flow will be dropped.
*                       The function only send the RPC msg to ethernet firmware core. 
*                       Completion of RPC msg processing is indicated by invokcation of 
*                       rpcCmdComplete part of Eth_ConfigType sturcture.
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeAllTraffic()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       9. Packet processing using Eth_Receive/Eth_Trasmit
*                       10. Eth_DispatchVirtmacUnsubscribeAllTraffic
*                       11. Wait for rpcCmdComplete() callback with status E_OK
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*
*  </pre> 
</div>
</div>
<a id="ga98d1612ed495fc9f278ba97c7d1123da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d1612ed495fc9f278ba97c7d1123da">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacSubscribeDstMac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacSubscribeDstMac </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>macAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac destination mac traffic subscription request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacSubscribeDstMac
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacSubscribeDstMac(CtrlIdx, macAddress)
*  Service ID[hex]   : 0x21
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx: Index of the controller within the context of the
*                                Ethernet Driver
*                      macAddress: Destination Mac address
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to subscribe to traffic with the given 
*                       destination macAddress to be routed to the rx flow
*                       of the Ethernet MCAL driver so that driver can receive
*                       the packets.The macAddres can be a unicast address
*                       allocated to the EthDriver (returned by Eth_GetPhysAddr())
*                       or a multicast address.
*                       The switch address resolution table should have an entry to
*                       route the destination mac address to the host port.
*                       For unicast address , the switch address resolution table 
*                       can be updated using Eth_DispatchVirtmacAddUnicastAddr()
*                       For multicast address , the switch address resolution table 
*                       can be updated using Eth_DispatchVirtmacAddMcastAddr()
*                       Note that broadcast address is usually subscribed to by 
*                       ethernet firmware so that it can respond to ARP requests.
*                       If ARP response handling by ethernet firmware is required,
*                       Eth driver should not be subscribed to broadcast address.
*                       The function only send the RPC msg to ethernet firmware core.
*                       Completion of RPC msg processing is indicated by invokcation of 
*                       rpcCmdComplete part of Eth_ConfigType sturcture.
*                       A failure status indicates ethernet firmware does not allow
*                       AUTOSAR Eth Driver to subscribe to default flow
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga10becd1a0c0135d82da9fb158860821b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10becd1a0c0135d82da9fb158860821b">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacUnsubscribeDstMac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacUnsubscribeDstMac </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>macAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac destination traffic unsubscription request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacUnsubscribeDstMac
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacUnsubscribeDstMac(CtrlIdx)
*  Service ID[hex]   : 0x22
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx. Index of the controller within the context of the
*                                Ethernet Driver
*                      macAddress: Destination Mac address
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to unsubscribe the specified destination 
*                       mac address flow traffic received on host port.
*                       The driver should have subscribed to the destination mac
*                       address previously by invoking 
*                       Eth_DispatchVirtmacSubscribeDstMac().
*                       On unsubscribing to destination mac flow , traffic with
*                       given destination mac address flow will be directed to
*                       default flow.
*                       The function only send the RPC msg to ethernet firmware core. 
*                       Completion of RPC msg processing is indicated by invokcation of 
*                       rpcCmdComplete part of Eth_ConfigType sturcture.
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       9. Packet processing using Eth_Receive/Eth_Trasmit
*                       10. Eth_DispatchVirtmacUnsubscribeDstMac()
*                       11. Wait for rpcCmdComplete() callback with status E_OK
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga564a29068f1ae69b1ce78f61c43dc0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga564a29068f1ae69b1ce78f61c43dc0ba">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacAssociateIPv4Macaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacAssociateIPv4Macaddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>ipv4Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>macAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac IPV4 address:destination mac association request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacAssociateIPv4Macaddr
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacAssociateIPv4Macaddr(CtrlIdx, ipv4Address, macAddress)
*  Service ID[hex]   : 0x23
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx: Index of the controller within the context of the
*                                Ethernet Driver
*                      ipv4Address: IPv4 address
*                      macAddress: Destination Mac address
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to associate the given unicast macaddress
*                       with the given IP address.
*                       The ethernet firmware maintains the ARP database for
*                       the ethernet driver and ethfw will respond to any ARP request.
*                       To correctly respond to ARP queries for IP address assigned to 
*                       the AUTOSAR network stack , the AUTOSAR stack must invoke
*                       this API so that the ARP database maintained by ethernet 
*                       firmware is updated.The macAddres must be a unicast address
*                       allocated to the EthDriver (returned by Eth_GetPhysAddr())
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       9. Send out DHCP request to acquire IP address for the 
*                          AUTOSAR network stack 
*                       10. On getting DHCP response with IP address, invoke 
*                           Eth_DispatchVirtmacAssociateIPv4Macaddr
*                       11. Wait for rpcCmdComplete() callback with status E_OK
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga859a393ce70911043218ba52be2ac056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga859a393ce70911043218ba52be2ac056">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacDisassociateIPv4Macaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacDisassociateIPv4Macaddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>ipv4Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac IPV4 address:destination mac disassociation request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacDisassociateIPv4Macaddr
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacDisassociateIPv4Macaddr(CtrlIdx, ipv4Address)
*  Service ID[hex]   : 0x24
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx: Index of the controller within the context of the
*                                Ethernet Driver
*                      ipv4Address: IPv4 address
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to remove the given IP address from the
*                       ARP database maintained by ethernet firmware.
*                       On deletion the ethfw will no longer respond to any ARP
*                       queries for the given IP address.
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       9. Send out DHCP request to acquire IP address for the 
*                          AUTOSAR network stack 
*                       10. On getting DHCP response with IP address, invoke 
*                           Eth_DispatchVirtmacAssociateIPv4Macaddr
*                       11. Wait for rpcCmdComplete() callback with status E_OK
*                       12. Network Packet processing 
*                       13. Eth_DispatchVirtmacDisassociateIPv4Macaddr
*                       14. Wait for rpcCmdComplete() callback with status E_OK
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga19a6d4a5213cf434b4640b6d16228169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a6d4a5213cf434b4640b6d16228169">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacAddUnicastAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacAddUnicastAddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>macAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_PortType&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vlanId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac addition of given unicast address to switch address resolution table request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacAddUnicastAddr
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacAddUnicastAddr(CtrlIdx, macAddress, port, vlanId)
*  Service ID[hex]   : 0x25
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx: Index of the controller within the context of the
*                                Ethernet Driver
*                      macAddress: Mac address to be added to the switch address resolution table
*                      port: Port to which macAddress should be routed.
*                      vlanId: Vlan Id associated with the mac Address. If vlan id is not needed, 0 should be passed
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to add the given unicast macaddress
*                       to the switch address resolution table with the given
*                       port and vlan id.
*                       These are static entries and not learned entries.
*                       On addition of entry switch would switch frames
*                       received with the given destination macAddress:vlan id
*                       combo to the given port.
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_DispatchVirtmacAddUnicastAddr()
*                       9. Wait for rpcCmdComplete() callback with status E_OK
*                       10. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga382b72ebf466a6aeac3be3a103ce074e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga382b72ebf466a6aeac3be3a103ce074e">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacAddMcastAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacAddMcastAddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>macAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numLsbToIgnore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vlanId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_PortListType *&#160;</td>
          <td class="paramname"><em>portList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac addition of given multicast address to switch address resolution table request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacAddMcastAddr
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacAddMcastAddr(CtrlIdx, macAddress, numLsbToIgnore, vlanId, portList)
*  Service ID[hex]   : 0x26
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx: Index of the controller within the context of the
*                                Ethernet Driver
*                      macAddress: Mac address to be added to the switch address resolution table
*                      numLsbToIgnore: Number of least significant bits in the multicast address to ignore.
*                                      This allows a range of multicast address to be handled by a single entry
*                      vlanId: Vlan Id associated with the mac Address. If vlan id is not needed, 0 should be passed
*                      portList: List of ports in the switch added to membership of the given multicast address
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to add the given multicast macaddress
*                       to the switch address resolution table with the given
*                       portlist as members and vlan id.
*                       On addition of entry switch would switch frames
*                       received with the given destination multicast macAddress:
*                       vlan id  combo to all the ports in the port list.
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_DispatchVirtmacAddMcastAddr()
*                       9. Wait for rpcCmdComplete() callback with status E_OK
*                       10. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*  </pre> 
</div>
</div>
<a id="ga7b228ef4ab0b76e825e345c3206587ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b228ef4ab0b76e825e345c3206587ac">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacDelAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacDelAddr </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>macAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vlanId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5eb94dd36576b9d12babc5a266ac7958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eb94dd36576b9d12babc5a266ac7958">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacAddVlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacAddVlan </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vlanId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eth_PortListType *&#160;</td>
          <td class="paramname"><em>portList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch virtual mac addition of given vlan id to switch address resolution table request to ethernet firmware. </p>
<pre class="fragment">*  Service name      : Eth_DispatchVirtmacAddVlan
*  Syntax            : Std_ReturnType Eth_DispatchVirtmacAddVlan(CtrlIdx, vlanId, portList)
*  Service ID[hex]   : 0x28
*  Sync/Async        : Asynchronous
*  Reentrancy        : Non-Reentrant
*  Parameters (in)   : CtrlIdx: Index of the controller within the context of the
*                                Ethernet Driver
*                      vlanId:  Vlan Id for which port membership is to be added to switch VLAN membership table
*                      portList: List of ports in the switch added to membership of the given vlan id
*  Parameters (inout): None
*  Parameters (out)  : None
*  Return value      :  Std_ReturnType
*                        E_OK: success
*                        E_NOT_OK: transmission failed
*
*  Description       :  The function dispatches RPC command to ethernet 
*                       firmware core to add the given vlan id
*                       to the switch address resolution table with the given
*                       portlist as members of the vlan.
*                       On addition of entry switch would switch frames
*                       with the given vlan only within the vlan membership
*                       specified by the port list. This applies to both 
*                       unicast and multicast address
*                       If configured in virtual mac mode application should
*                       invoke this API as follows:
*                       1. Eth_Init()
*                       2. Wait for fwRegisteredCb() callback 
*                       3. Eth_DispatchVirtmacInit
*                       4. Wait for rpcCmdComplete() callback with status E_OK
*                       5. Eth_ControllerInit()
*                       6. Eth_DispatchVirtmacSubscribeDstMac()
*                       7. Wait for rpcCmdComplete() callback with status E_OK
*                       8. Eth_DispatchVirtmacAddVlan()
*                       9. Wait for rpcCmdComplete() callback with status E_OK
*                       10. Eth_SetControllerMode(ETH_MODE_ACTIVE)
*                       The callbacks fwRegisteredCb() and rpcCmdComplete() are
*                       populated by the application as part of the Eth_ConfigType
*                       structure
*                       Note: The API adds the given portList also as the
*                       unregisterMcastFloodMask and registeredMulticastFloodMask
*                       The VLAN entry in the switch in added as inner vlan entry
*                       Further the following are hardcoded for the VLAN entry
*                           forceUntaggedEgressMask  = 0
*                           noLearnMask              = 0
*                           vidIngressCheck          = false
*                           limitIPNxtHdr            = false
*                           disallowIPFragmentation  = false
*                       Refer to CPSW documentation for details on these params
*  </pre> 
</div>
</div>
<a id="ga5497419600153ccd4099b8ce6c1fa37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5497419600153ccd4099b8ce6c1fa37d">&#9670;&nbsp;</a></span>Eth_DispatchVirtmacDelVlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_DispatchVirtmacDelVlan </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vlanId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga02d28635a9b76f5de124e7bb19e37b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02d28635a9b76f5de124e7bb19e37b1e">&#9670;&nbsp;</a></span>Eth_SendCustomNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Std_ReturnType Eth_SendCustomNotify </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>CtrlIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>notifyInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>notifyLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
