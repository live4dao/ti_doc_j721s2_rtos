<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>MCUSW Datasheet: CAN Response and Bootloader Demo Application</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCUSW Datasheet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('demo_boot_app_mcu_rtos_top.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CAN Response and Bootloader Demo Application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#demo_boot_app_mcu_rtos_intro">Introduction</a><ul><li class="level2"><a href="#demo_boot_app_mcu_rtos_profiled">Performance / Early CAN response</a></li>
<li class="level2"><a href="#demo_boot_app_mcu_rtos_depend_int">Internal Dependencies</a></li>
<li class="level2"><a href="#demo_boot_app_mcu_rtos_depend_ext">External Dependencies</a></li>
</ul>
</li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_flowchart">Flow Charts</a></li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_cfg">Compile Time Configurations for Boot Application</a></li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_can_cfg">Compile Time Configurations for CAN profiling / CAN fast response task</a></li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_setup_cfg">Test Setup / Configurations used</a></li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_prep_dep">Building dependent binaries</a><ul><li class="level2"><a href="#demo_boot_app_mcu_rtos_building_can_boot_app_mcu_rtos">Building can_boot_app_mcu_rtos</a></li>
<li class="level2"><a href="#demo_boot_app_mcu_rtos_building_main_domain_applications">Building main domain applications</a><ul><li class="level3"><a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_rtos">Creating RTOS appimage for main domain cores</a></li>
<li class="level3"><a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_hlos">Creating HLOS appimages for Linux or QNX</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_steps_2_run">Steps to run</a><ul><li class="level2"><a href="#demo_boot_app_mcu_rtos_main_domain_rtos_can_output_loopback">Sample output RTOS main domain apps, CAN Loop back mode</a></li>
<li class="level2"><a href="#demo_boot_app_mcu_rtos_main_domain_rtos_linux_can_output_loopback">Sample output RTOS main domain apps with Linux, CAN Loop back mode</a></li>
<li class="level2"><a href="#demo_boot_app_mcu_rtos_main_domain_rtos_qnx_can_output_loopback">Sample output RTOS main domain apps with QNX, CAN Loop back mode</a></li>
</ul>
</li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_known_issues">Known Issues</a></li>
<li class="level1"><a href="#demo_boot_app_mcu_rtos_rev_history">Document Revision History</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="demo_boot_app_mcu_rtos_intro"></a>
Introduction</h1>
<hr/>
<p> This application demonstrates the fast boot capability provided by the Octal SPI flash controller on J721E SoC. By default, it boots the main domain cores with basic applications, and also provides mechanisms to alternatively boot Linux or QNX on the MPU1_0 (i.e. A72) core. In addition, it demonstrates booting of the main domain cores via MMCSD media on J721E SoC. The application performs the following actions:</p><ol type="1">
<li>MCAL Can driver is hosted on MCU1_0</li>
<li>Transmit a 64 byte CAN message, or, alternatively, run CAN profiling</li>
<li>Boot the main domain cores with a sample application image</li>
<li>Optionally, boots a HLOS (Linux, QNX) on the main domain MPU1_0</li>
</ol>
<p>This facilitates an early CAN response feature, typically required in an automotive ECU, followed by booting of the main domain cores on the SoC.</p>
<h2><a class="anchor" id="demo_boot_app_mcu_rtos_profiled"></a>
Performance / Early CAN response</h2>
<p>Profiled Early CAN response at <a class="el" href="demo_can_profile_top.html#demo_can_profile_measurement_response_time">Link</a></p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_depend_int"></a>
Internal Dependencies</h2>
<p>This application depends on multiple components and are detailed in sections below</p><ol type="1">
<li>MCAL CAN Driver</li>
<li>MCAL BSW Stubs Stubs at <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcal_drv/mcal/Bsw_Stubs</em> are used. Functions CanIf_TxConfirmation () is required.</li>
<li>MCAL Configurations CAN &amp; DIO Configurations at <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/mcal_config</em> are used.</li>
</ol>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a> </p><hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_depend_ext"></a>
External Dependencies</h2>
<p>This application depends on <a href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_Foundational_Components.html#boot">Secondary Boot Loader (SBL)</a> component from Processor SDK RTOS. For further details on using the Secondary Boot Loader on J721E, see the <a href="http://software-dl.ti.com/jacinto7/esd/processor-sdk-rtos-jacinto7/latest/exports/docs/psdk_rtos_auto/docs/user_guide/developer_notes_sbl_boot.html?highlight=sbl">SBL J721E User Guide</a> and <a href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_Foundational_Components.html#am65x-j721e">SBL AM65x/J721E Details</a>.</p>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_flowchart"></a>
Flow Charts</h1>
<p>The following flow chart displays the main application on the MCU1_0, which can spawn up to 2 current tasks.</p>
<div class="image">
<img src="canbootapp_main.png" alt="canbootapp_main.png"/>
<div class="caption">
MCU1_0 CAN and Bootloader Application</div></div>
<p> The following flow chart displays the functionality of the CAN task if the CAN function is set to "can_profiling".</p>
<div class="image">
<img src="demo_can_profile_flowchart.png" alt="demo_can_profile_flowchart.png"/>
<div class="caption">
MCU1_0 CAN Profiling Task</div></div>
<p> The following flow chart displays the functionality of the CAN task if the CAN function is set to "can_fast_response".</p>
<div class="image">
<img src="canbootapp_can_response_task.png" alt="canbootapp_can_response_task.png"/>
<div class="caption">
MCU1_0 CAN Response Task</div></div>
<p> The following flow chart displays the functionality of the Boot task, as well as the applications started on the main domain cores.</p>
<div class="image">
<img src="canbootapp_boot_task.png" alt="canbootapp_boot_task.png"/>
<div class="caption">
MCU1_0 Boot Task and Main Domain Applications</div></div>
<p> <a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a> </p><hr/>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_cfg"></a>
Compile Time Configurations for Boot Application</h1>
<ol type="1">
<li>Enable/Disable Boot Task <br />
 The task that boots the main domain cores can be enabled/disabled. Below is the configuration flag for this feature.<ul>
<li>BOOTFUNC <br />
 Options are "enabled" (default) or "disabled".</li>
</ul>
</li>
<li>Boot Media <br />
 The boot task can either boot the main domain cores using an appimage located in OSPI or on an MMCSD card. Below is the configuration flag for this feature.<ul>
<li>BOOTMODE <br />
 Options are "ospi" (default) or "mmcsd". <br />
 Note that if the "ospi" option is utilized, the custom Secondary Boot Loader (sbl_cust_img) is expected to load the MCUSW Boot Application. If the "mmcsd" option is used, the mmcsd Secondary Boot Loader (sbl_mmcsd_img) should be used to load the MCUSW Boot Application.</li>
</ul>
</li>
<li>Boot Operating Systems for MPU1_0 <br />
 The boot task, by default, will load example applications written for TI Real-Time Operating System (RTOS) for all main domain cores (including MPU1_0). Alternatively, Linux or QNX operating systems could be loaded on MPU1_0. Below is the configuration flag for this feature.<ul>
<li>HLOSBOOT <br />
 Options are "none" (default, which means MPU1_0 TI RTOS application is loaded), "qnx", or "linux".</li>
</ul>
</li>
<li>CAN Functionality <br />
 The CAN task can either perform a fast CAN response, some CAN profiling over many messages, or be completely turned off. Below is the configuration flag for this feature.<ul>
<li>CANFUNC <br />
 Options are "can_fast_response" (default), "can_profiling", or "none" (to completely disable the CAN task).</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_can_cfg"></a>
Compile Time Configurations for CAN profiling / CAN fast response task</h1>
<ol type="1">
<li>Enable CAN transmit only mode <br />
 In transmit-only mode, messages can be received if an external CAN utility, like the CANOE tool or the PEAK tool, are connected to the EVM board. The J721E EVM has four CAN ports: MCU_MCAN0, MCU_MCAN1, MCAN0 and MCAN2. However, this demonstration only uses the first instance, MCU_MCAN0. Below are the configuration flags associated with this feature.<ul>
<li>CAN_LOOPBACK_ENABLE <br />
 Enable/Disable internal loopback mode. <br />
 Options are "STD_ON" or "STD_OFF". <br />
 CAN loopback configuration is present at <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/mcal_config/Can_Demo_Cfg/output/generated/soc/j721e/mcu1_0/include/Can_Cfg.h</em></li>
<li>CAN_TX_ONLY_MODE <br />
 Enable TX-only mode (vs. RX-only mode). <br />
 Options are "STD_ON" or "STD_OFF". <br />
 CAN TX only configuration is present at <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/can_resp.h</em> (if using CAN Response task) AND <em>mcuss_demos/boot_app_mcu_rtos/can_profile.h</em> (if using CAN Profile task)</li>
</ul>
</li>
<li>Use first instance of CAN peripheral only <br />
 Saves boot time by using only the first instance (MCU_MCAN0) of the CAN peripheral configured. Below is the configuration.<ul>
<li>APP_INSTANCE_1_INST_IN_CFG_ONLY <br />
 Use first instance of CAN peripheral only. <br />
 Options are "STD_ON" or "STD_OFF". <br />
 CAN configuration is present at <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/can_resp.h</em> (if using CAN Response task) AND <em>mcuss_demos/boot_app_mcu_rtos/can_profile.h</em> (if using CAN Profile task)</li>
</ul>
</li>
<li>Disable early prints before CAN response <br />
 When testing for early CAN response, it is important to disable any early prints that may be taking extra time before the CAN response actually starts. Below is the configuration.<ul>
<li>CAN_INITIAL_PRINT_DISABLE_BEFORE_CAN_RESPONSE <br />
 Enable this flag to minimize latencies due to early prints (disables the early prints). <br />
 Options are "STD_ON" or "STD_OFF". <br />
 CAN early prints configuration is present at <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/can_resp.h</em> (if using CAN Response task) AND <em>mcuss_demos/boot_app_mcu_rtos/can_profile.h</em> (if using CAN Profile task)</li>
</ul>
</li>
</ol>
<h1>Customizing CAN response / CAN profiling examples</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">For TX Only  </th><th class="markdownTableHeadNone">Flag Value  </th><th class="markdownTableHeadNone">Location   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">APP_INSTANCE_1_INST_IN_CFG_ONLY  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_LOOPBACK_ENABLE  </td><td class="markdownTableBodyNone">STD_OFF  </td><td class="markdownTableBodyNone">mcuss_demos/mcal_config/Can_Demo_Cfg/output/generated/soc/j721e/mcu1_0/include/Can_Cfg.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAN_TX_ONLY_MODE  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_INITIAL_PRINT_DISABLE_BEFORE_CAN_RESPONSE  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h (if desired, to reduce early latency in CAN response)   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Loopback  </th><th class="markdownTableHeadNone">Flag Value  </th><th class="markdownTableHeadNone">Location   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">APP_INSTANCE_1_INST_IN_CFG_ONLY  </td><td class="markdownTableBodyNone">STD_OFF  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_LOOPBACK_ENABLE  </td><td class="markdownTableBodyNone">STD_ON  </td><td class="markdownTableBodyNone">mcuss_demos/mcal_config/Can_Demo_Cfg/output/generated/soc/j721e/mcu1_0/include/Can_Cfg.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAN_TX_ONLY_MODE  </td><td class="markdownTableBodyNone">X  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">CAN_INITIAL_PRINT_DISABLE_BEFORE_CAN_RESPONSE  </td><td class="markdownTableBodyNone">STD_OFF  </td><td class="markdownTableBodyNone">mcuss_demos/boot_app_mcu_rtos/can_resp.h AND mcuss_demos/boot_app_mcu_rtos/can_profile.h   </td></tr>
</table>
<p>For instructions on how to measure early CAN response timing, see the <a class="el" href="demo_can_profile_top.html#demo_can_profile_early_can_res_j721e">Early CAN response on J721E section</a>.</p>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_setup_cfg"></a>
Test Setup / Configurations used</h1>
<h2>Loopback mode</h2>
<ol type="1">
<li>Supported EVM / SoC <div class="image">
<img src="canbootapp_j721e_can_loopback_setup.png" alt="canbootapp_j721e_can_loopback_setup.png"/>
<div class="caption">
Loopback Setup</div></div>
</li>
</ol>
<h2>TX Only mode</h2>
<ol type="1">
<li>CAN_HIGH of all the nodes on the bus shall be connected together. Similary CAN_LOW of all the nodes on the bus shall be connected together. <div class="image">
<img src="canbootapp_j721e_can_tx_setup.png" alt="canbootapp_j721e_can_tx_setup.png"/>
<div class="caption">
TxOnly Setup</div></div>
 <div class="image">
<img src="canbootapp_j721e_can_tx_setup_closeup.png" alt="canbootapp_j721e_can_tx_setup_closeup.png"/>
<div class="caption">
TxOnly Setup - Closeup</div></div>
 <a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a> <hr/>
 </li>
</ol>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_prep_dep"></a>
Building dependent binaries</h1>
<p>We need have the following binaries built from <em>psdk_rtos_auto_j7_xx_yy_xx_bb</em>:</p><ol type="1">
<li><b>sbl_cust_img</b> that loads SYSFW and initializes the OSPI flash. This SBL is used when utilizing MCUSW Boot App with BOOTMODE="ospi".</li>
<li><b>sbl_mmcsd</b> that loads SYSFW, initializes the board, and copies the MCUSW Boot App image from the SD card to DDR memory. This SBL is used when utilizing MCUSW Boot App with BOOTMODE="mmcsd".</li>
</ol>
<p>Apart from the above binaries, we need to build the <b>can_boot_app_mcu_rtos</b> that the SBL copies from either OSPI flash or the SD card, and does the following:</p><ol type="1">
<li>CAN loopback / transmit</li>
<li>Boot the available main domain cores: MPU1_0, MCU2_0, MCU2_1, MCU3_0, MCU3_1, C66X_0, C66X_1, C7X_0</li>
</ol>
<hr/>
 <h2>Building sbl_cust_img</h2>
<p>Go to <em>psdk_rtos_auto_j7_xx_yy_xx_bb/pdk/packages/ti/build</em> and run the following: </p><pre class="fragment">make -j BOARD=j721e_evm CORE=mcu1_0 BUILD_PROFILE=release sbl_cust_img  
</pre><hr/>
 <h2>Building sbl_mmcsd_img</h2>
<p>Go to <em>psdk_rtos_auto_j7_xx_yy_xx_bb/pdk/packages/ti/build</em> and run the following: </p><pre class="fragment">make -j BOARD=j721e_evm CORE=mcu1_0 BUILD_PROFILE=release sbl_mmcsd_img
</pre><hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_building_can_boot_app_mcu_rtos"></a>
Building can_boot_app_mcu_rtos</h2>
<p>Go to <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/build</em> and run the following:</p>
<div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos BOARD=j721e_evm SOC=j721e BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --><p>The default mode is OSPI boot and CAN fast response, with all main domain cores loaded with TI RTOS images.</p>
<p>Some common configurations also supported include: <br />
</p><ol type="1">
<li>Booting from MMCSD (all TI RTOS images for main domain cores): <br />
 <div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos BOOTMODE=mmcsd BOARD=j721e_evm SOC=j721e BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --></li>
<li>Booting HLOS on MPU1_0 with TI RTOS images on other main domain cores (OSPI mode): <br />
 <div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=linux BOARD=j721e_evm SOC=j721e BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=qnx BOARD=j721e_evm SOC=j721e BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --></li>
<li>Booting HLOS on MPU1_0 with TI RTOS images on other main domain cores (MMCSD mode): <br />
 <div class="fragment"><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=linux BOOTMODE=mmcsd BOARD=j721e_evm SOC=j721e BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div><div class="line">make -s -j can_boot_app_mcu_rtos HLOSBOOT=qnx BOOTMODE=mmcsd BOARD=j721e_evm SOC=j721e BUILD_PROFILE=release CORE=mcu1_0 BUILD_OS_TYPE=tirtos</div></div><!-- fragment --></li>
</ol>
<p>The output appimage "can_boot_app_mcu_rtos_mcu1_0_release.appimage" will be placed in <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/j721e_evm</em> directory.</p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_building_main_domain_applications"></a>
Building main domain applications</h2>
<h3><a class="anchor" id="demo_boot_app_mcu_rtos_building_main_domain_applications_rtos"></a>
Creating RTOS appimage for main domain cores</h3>
<p>Go to <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/scripts</em> and run the following: ./makemulticore.sh</p>
<p>After building all the binaries for each main domain core, this script calls the constructappimage.sh script to construct a single main-domain appimage. This appimage will be utilized by the MCUSW boot application to load the main domain cores. The output appimage "multicore_split_with_DSPs.appimage" will be placed in <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm</em> directory, and this appimage contains binaries for the following cores: MPU1_0, MCU2_0, MCU2_1, MCU3_0, MCU3_1, C66X_0, C66X_1, C7X_0.</p>
<p>The contents of this appimage can be customized by slight modification of the constructappimage.sh script. This script contains some variables for the most-likely appimage cases in the main domain:</p><ol type="1">
<li><em>mpu_rtos_enabled</em> - This flag controls if the appimage will contain MPU1_0 binary or not. By default, this flag is set, and, thus, includes example RTOS MPU1_0 application. If Linux or QNX is instead desired on MPU1_0, this flag should be set to 0, and then re-run the constructappimage.sh.</li>
<li><em>split_mode</em> - This flag controls if main MCU's are run in split mode or not. If it is set to 0, the MCU2_1 and MCU3_1 images will be left out of the appimage. Note that the name of the generated output changes when disabling this flag.</li>
<li><em>dsp_binaries_included</em> - This flag control if C66 and C7 DSP binaries are included or not. Note that the name of the generated output changes when disabling this flag.</li>
</ol>
<p>Note that this same constructappimage.sh script could be utilized to formulate main-domain appimages with other binaries on each core. One could simply copy these ELF images to the <em>mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm</em> directory, and then modify the ElfImages, CoreRprcFiles, and CoreIds arrays within the script before running it.</p>
<h3><a class="anchor" id="demo_boot_app_mcu_rtos_building_main_domain_applications_hlos"></a>
Creating HLOS appimages for Linux or QNX</h3>
<p>In the common, alternative case where Linux/QNX is booted on MPU1_0, the following steps should be followed:</p><ol type="1">
<li>Rebuild the can_boot_app_mcu_rtos image with the <em>HLOSBOOT</em> flag set to either "linux" or "qnx", as described in the <a href="#demo_boot_app_mcu_rtos_building_can_boot_app_mcu_rtos">Building can_boot_app_mcu_rtos section</a>.</li>
<li>Reconstruct the main domain RTOS application image using the constructappimage.sh script with the <em>mpu_rtos_enabled</em> flag disabled.</li>
<li>Go to the <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/scripts/hlos</em> directory and edit the constructappimageshlos.sh by setting the "OS" and Linux-specific or QNX-specific paths to match your setup. This assumes that the Linux/QNX binaries have already been created, as this script only creates appimages based off these already-created HLOS binaries.</li>
<li>After modifying the user-defined variables in the constructappimageshlos.sh script, run this script. If run correctly, the <em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm</em> directory should now contain the following files:<ol type="a">
<li>For Linux - atf_optee.appimage, tidtb_linux.appimage, and tikernelimage_linux.appimage</li>
<li>For QNX - atf_optee.appimage and ifs_qnx.appimage</li>
</ol>
</li>
</ol>
<hr/>
 <h1><a class="anchor" id="demo_boot_app_mcu_rtos_steps_2_run"></a>
Steps to run</h1>
<h2>Writing needed binaries to OSPI</h2>
<p>To run the default TI RTOS applications on all the main domain cores, flash the following binaries in OSPI memory at the respective offsets (in hex) as given below:</p>
<ol type="1">
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/pdk/packages/ti/boot/sbl/binary/j721e_evm/cust/bin/sbl_cust_img_mcu1_0_release.tiimage</em> @ <b>0</b></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/pdk/packages/ti/drv/sciclient/soc/V1/sysfw.bin</em> @ <b>40000</b></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/j721e_evm/can_boot_app_mcu_rtos_mcu1_0_release.appimage</em> @ <b>a0000</b></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/multicore_split_with_DSPs.appimage</em> @ <b>1700000</b></li>
</ol>
<p>To alternatively boot Linux on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also flash the following binaries in OSPI memory at the respective offsets (in hex):</p><ol type="1">
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/atf_optee.appimage</em> @ <b>e0000</b></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/tidtb_linux.appimage</em> @ <b>16c0000</b></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/tikernelimage_linux.appimage</em> @ <b>6c0000</b></li>
</ol>
<p>To alternatively boot QNX on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also flash the following binaries in OSPI memory at the respective offsets (in hex):</p><ol type="1">
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/atf_optee.appimage</em> @ <b>e0000</b></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/ifs_qnx.appimage</em> @ <b>6c0000</b></li>
</ol>
<p>Note that, for Linux/QNX binaries, the multicore_split_with_DSPs.appimage and can_boot_app_mcu_rtos_mcu1_0_release.appimage images will also need to be rebuilt, as described in <a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_hlos">Creating HLOS appimages for Linux or QNX</a>, and redownloaded to their designated OSPI locations above.</p>
<p>Refer <a href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Uniflash Programming Guide</a> to learn how to program the binaries at the respective offset in the flash.</p>
<h2>Writing needed binaries to MMCSD</h2>
<p>To run the default TI RTOS applications on all the main domain cores, copy the following binaries onto the MMCSD card:</p>
<ol type="1">
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/pdk/packages/ti/boot/sbl/binary/j721e_evm/cust/bin/sbl_mmcsd_img_mcu1_0_release.tiimage</em>, rename to <em>tiboot3.bin</em></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/pdk/packages/ti/drv/sciclient/soc/V1/sysfw.bin</em></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/binary/can_boot_app_mcu_rtos/bin/j721e_evm/can_boot_app_mcu_rtos_mcu1_0_release.appimage</em>, rename to <em>app</em></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/multicore_split_with_DSPs.appimage</em>, rename to <em>lateapp</em></li>
</ol>
<p>To alternatively boot Linux on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also copy the following binaries onto the MMCSD card:</p><ol type="1">
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/atf_optee.appimage</em></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/tidtb_linux.appimage</em></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/tikernelimage_linux.appimage</em></li>
</ol>
<p>To alternatively boot QNX on MPU1_0 (while still booting TI RTOS applications on the other main domain cores), also copy the following binaries onto the MMCSD card:</p><ol type="1">
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/atf_optee.appimage</em></li>
<li><em>psdk_rtos_auto_j7_xx_yy_xx_bb/mcusw/mcuss_demos/boot_app_mcu_rtos/main_domain_apps/binary/bin/j721e_evm/ifs_qnx.appimage</em></li>
</ol>
<p>Note that, for Linux/QNX binaries, the multicore_split_with_DSPs.appimage and can_boot_app_mcu_rtos_mcu1_0_release.appimage images will also need to be rebuilt, as described in <a href="#demo_boot_app_mcu_rtos_building_main_domain_applications_hlos">Creating HLOS appimages for Linux or QNX</a>, and copied again to the MMCSD card.</p>
<h2>Running the demonstration</h2>
<ol type="1">
<li>Ensure boot mode of the EVM is configured as described in (<a class="el" href="mcusw_c_ug_top.html#mcusw_depend_evm_j721e_mmcsd">J721E EVM MMC/SD Boot Mode</a>) or (<a class="el" href="mcusw_c_ug_top.html#mcusw_depend_evm_j721e_ospi">J721E EVM OSPI Boot Mode</a>)</li>
<li>UART / Console for demo application logs / messages<ul>
<li>J721E EVM has 2 UART ports</li>
<li>UART port named <b> MCU UART </b> would be used when demo applications are hosted on MCU R5F (e.g. MCU1_0)</li>
<li>UART port named <b> UART </b> would be used when demo applications are hosted on MAIN R5F (e.g. MCU2_1, etc.)</li>
<li>Refer EVM Image at (<a class="el" href="mcusw_c_ug_top.html#mcusw_depend_evm_j721e">J721E EVM</a>)</li>
</ul>
</li>
<li>Connect two separate micro USB cables between MCU UART port (J43) &lt;==&gt; host PC and Main UART port (J44) &lt;==&gt; host PC</li>
<li>Configure two separate instances of a serial console application on host PC to use MCU UART port, channel #2 (i.e. second UART instance) and Main UART port, channel #2 (i.e. fourth UART instance), respectively. For each instance, use a '115200 8N1' configuration.<ol type="a">
<li>If also testing Linux/QNX booting, also configure Main UART port, channel #1 (i.e. third UART instance) with a similar '115200 8N1' configuration.</li>
</ol>
</li>
<li>Power ON the board and confirm the boot logs on serial console</li>
</ol>
<p>After the application has completed, the UART logs are contained on the following UART ports:</p><ol type="1">
<li>MCU UART port, channel #2 (i.e. second UART instance) - MCU R5F CAN Boot Application logs</li>
<li>Main UART port, channel #1 (i.e. third UART instance) - Linux/QNX boot logs (only if Linux/QNX build enabled)</li>
<li>Main UART port, channel #2 (i.e. fourth UART instance) - Main Domain RTOS application logs</li>
</ol>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a> </p><hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_main_domain_rtos_can_output_loopback"></a>
Sample output RTOS main domain apps, CAN Loop back mode</h2>
<p>Below is the log for CAN Boot App when CAN is configured in loop-back mode, and all main domain cores run the RTOS example application (OSPI boot mode).</p>
<p>MCU UART Port#2 (second UART port on PC): </p><pre class="fragment">CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000c0 Message Length is 64
CAN Response App:Test completed for 0 instance

CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000b0 Message Length is 64
CAN Response App:Test completed for 1 instance

CAN Response App: 8192 bytes used for stack
CAN Response App:Early CAN completed!!!
Boot App: Started at 419 usec
Boot App: Started requesting all cores at 178952 usec
Boot App: Completed requesting all cores at 179403 usec
Boot App: Started copying and image parsing at 179403 usec
Boot App: Completed copying and image parsing at 209263 usec
Boot App: Total Num booted cores = 8
Boot App: Booted Core ID #6 at 210041 usecs
Boot App: Booted Core ID #7 at 210379 usecs
Boot App: Booted Core ID #8 at 210730 usecs
Boot App: Booted Core ID #9 at 211068 usecs
Boot App: Booted Core ID #10 at 211454 usecs
Boot App: Booted Core ID #11 at 211851 usecs
Boot App: Booted Core ID #12 at 212372 usecs
Boot App: Booted Core ID #0 at 214162 usecs
Boot App: Stage #0 finished at 212372 usecs
Boot App: Stage #1 finished at 214163 usecs

MCU Boot Task started at 411 usecs and finished at 2427899 usecs
</pre><p>Main UART Port#2 (fourth UART port on PC): </p><pre class="fragment">MPU1_0 started running at 224845 usecs
MPU1_0 initialized at 225166 usecs
C7X_0 started running at 220160 usecs
C7X_0 initialized at 220362 usecs
MCU2_0 started running at 275287 usecs
MCU2_0 initialized at 276683 usecs
MCU2_1 started running at 275623 usecs
MCU2_1 initialized at 277055 usecs
MCU3_0 started running at 275976 usecs
MCU3_0 initialized at 277528 usecs
MCU3_1 started running at 276293 usecs
MCU3_1 initialized at 278043 usecs
C66X_0 started running at 248789 usecs
C66X_0 initialized at 250065 usecs
C66X_1 started running at 249619 usecs
C66X_1 initialized at 250484 usecs
</pre><p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_main_domain_rtos_linux_can_output_loopback"></a>
Sample output RTOS main domain apps with Linux, CAN Loop back mode</h2>
<p>Below is the log for CAN Boot App when CAN is configured in loop-back mode, and all main domain cores run the RTOS example application (OSPI boot mode), except for MPU1_0 running Linux instead.</p>
<p>MCU UART Port#2 (second UART port on PC): </p><pre class="fragment">CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000c0 Message Length is 64
CAN Response App:Test completed for 0 instance

CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000b0 Message Length is 64
CAN Response App:Test completed for 1 instance

CAN Response App: 8192 bytes used for stack
CAN Response App:Early CAN completed!!!
Boot App: Started at 417 usec
Boot App: Started requesting all cores at 178920 usec
Boot App: Completed requesting all cores at 179373 usec
Boot App: Started copying and image parsing at 179374 usec
Boot App: Completed copying and image parsing at 472505 usec
Boot App: Total Num booted cores = 8
Boot App: Booted Core ID #6 at 473293 usecs
Boot App: Booted Core ID #7 at 473630 usecs
Boot App: Booted Core ID #8 at 473968 usecs
Boot App: Booted Core ID #9 at 474314 usecs
Boot App: Booted Core ID #10 at 474701 usecs
Boot App: Booted Core ID #11 at 475087 usecs
Boot App: Booted Core ID #12 at 475618 usecs
Boot App: Booted Core ID #0 at 477399 usecs
Boot App: Stage #0 finished at 475619 usecs
Boot App: Stage #1 finished at 477400 usecs

MCU Boot Task staòôåäàáôàôðùàõóåãóàáîäàæéîéóèåäàáôàòöùðóù÷àõóåãóíííê
</pre><p>Main UART Port#1 (third UART port on PC): <br />
</p><pre class="fragment">NOTICE:  BL31: v2.2(debug):ti2019.06-rc3
NOTICE:  BL31: Built : 11:29:38, Jan 22 2020
INFO:    GICv3 without legacy support detected. ARM GICv3 driver initialized in EL3
INFO:    SYSFW ABI: 2.9 (firmware rev 0x0013 '19.12.0-v2019.12 (Terrific Llam')
INFO:    BL31: Initializing runtime services
INFO:    BL31: cortex_a72: CPU workaround for cve_2018_3639 was applied
INFO:    BL31: Initializing BL32
I/TC:
I/TC: OP-TEE version: ti2019.06-rc3 (gcc version 8.3.0 (GNU Toolchain for the A-profile Architecture 8.3-2019.03 (arm-rel-8.36))) #1 Wed Jan 22 17:38:01 UTC 2020 aarch64
I/TC: Initialized
INFO:    BL31: Preparing for EL3 exit to normal world
INFO:    Entry point address = 0x80080000
INFO:    SPSR = 0x3c9
[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd080]
[    0.000000] Linux version 4.19.90-00036-g048e30751d3f-dirty (a0217421@thrush) (gcc version 8.3.0 (GNU Toolchain for the A-profile Architecture 8.3-2019.03 (arm-rel-8.36))) #2 SMP PREEMPT Thu Jan 23 15:16:11 CST 2020
[    0.000000] Machine model: Texas Instruments K3 J721E SoC

...

[  OK  ] Started Process Core Dump (PID 712/UID 0).

 _____                    _____           _         _
|  _  |___ ___ ___ ___   |  _  |___ ___  |_|___ ___| |_
|     |  _| .'| . | . |  |   __|  _| . | | | -_|  _|  _|
|__|__|_| |__,|_  |___|  |__|  |_| |___|_| |___|___|_|
              |___|                    |___|

Arago Project http://arago-project.org j7-evm ttyS2

Arago 2019.11 j7-evm ttyS2

j7-evm login:
</pre><p>Main UART Port#2 (fourth UART port on PC): </p><pre class="fragment">C7X_0 started running at 483356 usecs
C7X_0 initialized at 483571 usecs
MCU2_0 started running at 539319 usecs
MCU2_0 initialized at 540758 usecs
MCU2_1 started running at 539682 usecs
MCU2_1 initialized at 541158 usecs
MCU3_0 started running at 540029 usecs
MCU3_0 initialized at 541620 usecs
MCU3_1 started running at 540346 usecs
MCU3_1 initialized at 542112 usecs
C66X_0 started running at 511931 usecs
C66X_0 initialized at 513220 usecs
C66X_1 started running at 512725 usecs
C66X_1 initialized at 513604 usecs
</pre><p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
 <h2><a class="anchor" id="demo_boot_app_mcu_rtos_main_domain_rtos_qnx_can_output_loopback"></a>
Sample output RTOS main domain apps with QNX, CAN Loop back mode</h2>
<p>Below is the log for CAN Boot App when CAN is configured in loop-back mode, and all main domain cores run the RTOS example application (OSPI boot mode), except for MPU1_0 running QNX instead.</p>
<p>MCU UART Port#2 (second UART port on PC): </p><pre class="fragment">CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000c0 Message Length is 64
CAN Response App:Test completed for 0 instance

CAN Response App:NOTE : Operating in internal loop-back mode
CAN Response App:Message Id Received 800000b0 Message Length is 64
CAN Response App:Test completed for 1 instance

CAN Response App: 8192 bytes used for stack
CAN Response App:Early CAN completed!!!
Boot App: Started at 417 usec
Boot App: Started requesting all cores at 178886 usec
Boot App: Completed requesting all cores at 179339 usec
Boot App: Started copying and image parsing at 179340 usec
Boot App: Completed copying and image parsing at 521212 usec
Boot App: Total Num booted cores = 8
Boot App: Booted Core ID #6 at 522004 usecs
Boot App: Booted Core ID #7 at 522341 usecs
Boot App: Booted Core ID #8 at 522679 usecs
Boot App: Booted Core ID #9 at 523028 usecs
Boot App: Booted Core ID #10 at 523414 usecs
Boot App: Booted Core ID #11 at 523800 usecs
Boot App: Booted Core ID #12 at 524331 usecs
Boot App: Booted Core ID #0 at 526111 usecs
Boot App: Stage #0 finished at 524331 usecs
Boot App: Stage #1 finished at 526112 usecs

MCU Boot Task started at 408 usecs and finished at 2739147 usecs
</pre><p>Main UART Port#1 (third UART port on PC): <br />
</p><pre class="fragment">NOTICE:  BL31: v2.2(debug):ti2019.06-rc3
NOTICE:  BL31: Built : 11:29:38, Jan 22 2020
INFO:    GICv3 without legacy support detected. ARM GICv3 driver initialized in EL3
INFO:    SYSFW ABI: 2.9 (firmware rev 0x0013 '19.12.0-v2019.12 (Terrific Llam')
INFO:    BL31: Initializing runtime services
INFO:    BL31: cortex_a72: CPU workaround for cve_2018_3639 was applied
INFO:    BL31: Initializing BL32
I/TC:
I/TC: OP-TEE version: ti2019.06-rc3 (gcc version 8.3.0 (GNU Toolchain for the A-profile Architecture 8.3-2019.03 (arm-rel-8.36))) #1 Wed Jan 22 17:38:01 UTC 2020 aarch64
I/TC: Initialized
INFO:    BL31: Preparing for EL3 exit to normal world
INFO:    Entry point address = 0x80080000
INFO:    SPSR = 0x3c9
MMU: 16-bit ASID 44-bit PA TCR_EL1=b5183519
cpu0: MPIDR=80000000
cpu0: MIDR=411fd080 Cortex-A72 r1p0
cpu0: CWG=4 ERG=4 Dminline=4 Iminline=4 PIPT
cpu0: CLIDR=a200023 LoUU=1 LoC=2 LoUIS=1
cpu0: L1 Icache 48K linesz=64 set/way=256/3
cpu0: L1 Dcache 32K linesz=64 set/way=256/2
cpu0: L2 Unified 1024K linesz=64 set/way=1024/16
Loading IFS...done
cpu1: MPIDR=80000001
cpu1: MIDR=411fd080 Cortex-A72 r1p0
cpu1: CWG=4 ERG=4 Dminline=4 Iminline=4 PIPT
cpu1: CLIDR=a200023 LoUU=1 LoC=2 LoUIS=1
cpu1: L1 Icache 48K linesz=64 set/way=256/3
cpu1: L1 Dcache 32K linesz=64 set/way=256/2
cpu1: L2 Unified 1024K linesz=64 set/way=1024/16

System page at phys:0000000080011000 user:ffffff8040252000 kern:ffffff8040251000
Starting next program at vffffff8060058ae0
MMFLAGS=1
All ClockCycles offsets within tolerance
Welcome to QNX Neutrino 7.0 on TI J721E EVM Board!!
start serial driver
Toggle GPIO_uSD_PWR_EN for uSD
data: ch c2h
data: 4h c2h
data: 4h c6h
data: ch c6h
data: 4h ceh
data: 7h fch
MASTER_SEND: Input/output error
Setting environment variables...
done..
Looking for user script to run: /sd/user.sh
Unable to access /sd/stage/user.sh
done...
J7EVM# 
</pre><p>Main UART Port#2 (fourth UART port on PC): </p><pre class="fragment">C7X_0 started running at 532066 usecs
C7X_0 initialized at 532279 usecs
MCU2_0 started running at 587960 usecs
MCU2_0 initialized at 589393 usecs
MCU2_1 started running at 588330 usecs
MCU2_1 initialized at 589802 usecs
MCU3_0 started running at 588679 usecs
MCU3_0 initialized at 590268 usecs
MCU3_1 started running at 588988 usecs
MCU3_1 initialized at 590761 usecs
C66X_0 started running at 560549 usecs
C66X_0 initialized at 561848 usecs
C66X_1 started running at 561390 usecs
C66X_1 initialized at 562270 usecs
</pre><p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_known_issues"></a>
Known Issues</h1>
<ol type="1">
<li>When booting Linux on MPU1_0, writes to the Main UART port #1 can also cause inaccurate/corrupted writes by MCUSW Boot App (to MCU UART port #2) and main domain RTOS applications (to Main UART port #2). Note that the end of the MCUSW Boot App log in the <a href="#demo_boot_app_mcu_rtos_main_domain_rtos_linux_can_output_loopback">Linux + RTOS boot sample logs</a> shows this UART data inaccuracy. The Linux login might be written to these UART ports as well (i.e. MCU UART port #2). The user should only interact with Linux on the Main UART port #1 (i.e. third UART instance).</li>
<li>When booting Linux or QNX on MPU1_0 from MMCSD, the reading of the kernel (Linux) or IFS (QNX) images is not optimized for MMCSD. Thus, the start of the booting of Linux/QNX may not happen until about 8-10 seconds after the MCUSW CAN Boot App has started. Note that customers are encouraged to utilize OSPI boot media to get best startup times.</li>
</ol>
<p><a class="el" href="demo_boot_app_mcu_rtos_top.html">Back To Top</a></p>
<hr/>
<h1><a class="anchor" id="demo_boot_app_mcu_rtos_rev_history"></a>
Document Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Revision  </th><th class="markdownTableHeadNone">Date  </th><th class="markdownTableHeadNone">Author  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Status   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.1  </td><td class="markdownTableBodyNone">16 Apr 2019  </td><td class="markdownTableBodyNone">Somnath  </td><td class="markdownTableBodyNone">Initial Version  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.2  </td><td class="markdownTableBodyNone">8 Aug 2019  </td><td class="markdownTableBodyNone">Sunil M S  </td><td class="markdownTableBodyNone">Updates logs for release 00.09.01  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0.3  </td><td class="markdownTableBodyNone">30 Jan 2020  </td><td class="markdownTableBodyNone">Danny Jochelson  </td><td class="markdownTableBodyNone">New Version For TIRTOS Boot App  </td><td class="markdownTableBodyNone">Approved   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">0.4  </td><td class="markdownTableBodyNone">4 Feb 2020  </td><td class="markdownTableBodyNone">Jonathan Bergsagel  </td><td class="markdownTableBodyNone">Updated for CAN boot app CAN response compile options  </td><td class="markdownTableBodyNone">Approved   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="demo_top.html">MCUSS Demo Applications</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
